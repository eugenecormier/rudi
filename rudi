#!/usr/bin/env python3

##################################################
# IMPORTS
##################################################

# imports modules to grab cli arguments and show helpful
# hints from --help
import argparse

# this allows us to call lilypond
from subprocess import call

# for copyright line
import time

# brings in module to grab randomly from list
import random



##################################################
# HELP & ARGUMENTS
##################################################

# program explanation
##########################
cliargs = argparse.ArgumentParser(description='Random Music Theory Test Generator.' , usage='%(prog)s [options]' )

# cli arguments
##########################

cliargs.add_argument( '--title' , nargs='?' , default='Preliminary Rudiments Worksheet' , help='Change the default page title' )

cliargs.add_argument( '--copyright' , nargs='?' , default='' , help='Change the copyright line' )

cliargs.add_argument( '--all' , help='Add All Subjects' , action='store_true' )

cliargs.add_argument( '--aural-intervals' , type=int , nargs='?' , const=10 , metavar='#' , help='Add boxes for aural interval testing (default 10)' )

cliargs.add_argument( '--clefs' , type=int , nargs='?' , const=10 , metavar='#' , help='Draw Clefs (default 10)' )

cliargs.add_argument( '--notes' , type=int , nargs='?' , const=10 , metavar='#' , help='Identify/Write Note Names (default 10)' )

cliargs.add_argument( '--durations' , type=int , nargs='?' , const=9 , metavar='#' , help='Write Notes/Rests Equal To... (default 9)' )

cliargs.add_argument( '--cst-dst-wt' , type=int , nargs='?' , const=10 , metavar='#' , help='Chromatic/Diatonic Semitones & Wholetones (default 10)' )

cliargs.add_argument( '--circle-of-fifths' , help='Draw Circle of Fifths' , action='store_true' )

cliargs.add_argument( '--key-sigs' , help='Draw Key Signatures' , action='store_true' )

cliargs.add_argument( '--scale-degrees' , type=int , nargs='?' , const=10 , metavar='#' , help='Identify Scale Degrees (default 10)' )

cliargs.add_argument( '--relative-keys' , type=int , nargs='?' , const=10 , metavar='#' , help='Write relative maj/min keys (default 10)' )

cliargs.add_argument( '--all-scales' , type=int , nargs='?' , const=16 , metavar='#' , help='Identify/Write All Scales (default 16)' )

cliargs.add_argument( '--s-maj' , type=int , nargs='?' , const=16 , metavar='#' , help='Identify/Write Major Scales (default 16)' )

cliargs.add_argument( '--s-min' , type=int , nargs='?' , const=16 , metavar='#' , help='Identify/Write Minor Scales (default 16)' )

cliargs.add_argument( '--s-chroctwt' , type=int , nargs='?' , const=16 , metavar='#' , help='Identify/Write Chromatic, Octatonic & Wholetone Scales (default 16)' )

cliargs.add_argument( '--s-pentblues' , type=int , nargs='?' , const=16 , metavar='#' , help='Identify/Write Pentatonic & Blues Scales (default 16)' )

cliargs.add_argument( '--s-modes' , type=int , nargs='?' , const=16 , metavar='#' , help='Identify/Write Modes (default 16)' )

cliargs.add_argument( '--all-simple-intervals' , type=int , nargs='?' , const=10 , metavar='#' , help='Identify/Write Hard Simple Intervals (default 10)' )

cliargs.add_argument( '--easy-simple-intervals' , type=int , nargs='?' , const=10 , metavar='#' , help='Identify/Write Easy Simple Intervals (default 10)' )

cliargs.add_argument( '--hard-simple-intervals' , type=int , nargs='?' , const=10 , metavar='#' , help='Identify/Write Hard Simple Intervals (default 10)' )

cliargs.add_argument( '--intervals-in-scales' , type=int , nargs='?' , const=3 , metavar='#' , help='Identify Scales In Which A Given Interval Occurs (default 3)' )

cliargs.add_argument( '--all-chords' , type=int , nargs='?' , const=8 , metavar='#' , help='Identify/Write Chords (default 8)' )

cliargs.add_argument( '--all-chords-inv' , type=int , nargs='?' , const=8 , metavar='#' , help='Identify/Write Chords with inversions (default 8)' )

cliargs.add_argument( '--c-maj-min' , type=int , nargs='?' , const=8 , metavar='#' , help='Identify/Write Major/Minor Chords (default 8)' )

cliargs.add_argument( '--c-maj-min-inv' , type=int , nargs='?' , const=8 , metavar='#' , help='Identify/Write Major/Minor Chords with inversions (default 8)' )

cliargs.add_argument( '--c-dim-aug' , type=int , nargs='?' , const=8 , metavar='#' , help='Identify/Write Diminished/Augmented Chords (default 8)' )

cliargs.add_argument( '--c-dim-aug-inv' , type=int , nargs='?' , const=8 , metavar='#' , help='Identify/Write Diminished/Augmented Chords with inversions (default 8)' )

cliargs.add_argument( '--c-dom7' , type=int , nargs='?' , const=6 , metavar='#' , help='Identify/Write Dominant 7th Chords (default 6)' )

cliargs.add_argument( '--c-dom7-inv' , type=int , nargs='?' , const=6 , metavar='#' , help='Identify/Write Dominant 7th Chords with inversions (default 6)' )

cliargs.add_argument( '--c-other-7ths' , type=int , nargs='?' , const=8 , metavar='#' , help='Identify/Write M7, m7, half-dim7 and full-dim7 Chords (default 8)' )

cliargs.add_argument( '--c-ext-chords' , type=int , nargs='?' , const=5 , metavar='#' , help='Identify Extended Chords (Cluster, Quartal & Poly) (default 5)' )

cliargs.add_argument( '--cadences' , type=int , nargs='?' , const=3 , metavar='#' , help='Identify/Write Cadences (default 3)' )

cliargs.add_argument( '--transposition' , type=int , nargs='?' , const=1 , metavar='#' , help='Transpose the given example, # is the example (default 1 = random)' )

cliargs.add_argument( '--time-sigs' , type=int , nargs='?' , const=1 , metavar='#' , help='Time Signatures, # is the example (default 1 = random)' )

cliargs.add_argument( '--detect-errors' , type=int , nargs='?' , const=1 , metavar='#' , help='Detect Notation Errors, # is the example (default 1 = random)' )



##################################################
# VARIABLES & LISTS
##################################################

# Lilypond file
fillInSheet = 'theory-sheet-' + time.strftime("%Y-%m-%d")  + '.ly'
keySheet = 'theory-sheet-key-' + time.strftime("%Y-%m-%d")  + '.ly'

# Fonts
# 'Linux Libertine Capitals' , 'Sans'
headerfont = 'Linux Libertine Capitals'

# Headers
headera = [
  '\\version "2.16.2"\n' ,
  # Titles
  '\header {\n' ,
    '\ttitle = \markup { \override #\'(font-name . "' ,
    headerfont
  ]
headersheeta = [
    '") \\fontsize #+3 "'
  ]
headerkeya = [
    '") \\fontsize #+3 "'
  ]
headersheetb = [
    '" }\n'
  ]
headerkeyb = [
    '  " \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { Key }} }\n'
  ]
headerb = [
    '\tsubtitle = \markup { \override #\'(font-name . "' ,
    headerfont ,
    '") \\fontsize #+2 "Name:_______________________" }\n' ,
    '\ttagline = \markup { \override #\'(font-name . "' ,
    headerfont ,
    '") \\fontsize #+1 "'
    ]
headerc = [
    ' ',
    time.strftime("%A, %B %d, %Y") ,
    '" }\n' ,
    '\t}\n' ,
  # Paper layout
  '\\paper {\n' ,
    '\tragged-right = ##f\n' ,
    '\tragged-bottom = ##f\n' ,
    '\tragged-last-bottom = ##f\n' ,
    '\t#(set-paper-size "letter")\n' ,
    '\t}\n' ,
  '#(set-global-staff-size 22)\n' ,
  'indent = 0\n' ,
  '\n' ,
  # Variables
  'notimesig = { \override Staff.TimeSignature #\'transparent = ##t }\n' ,
  'nobarline = { \override Staff.BarLine #\'transparent = ##t }\n' ,
  'nobarlinenumbers = { \override Score.BarNumber #\'transparent = ##t }\n' ,
  'noclef = { \override Staff.Clef #\'transparent = ##t }\n' ,
  'nokeycancel = { \set Staff.printKeyCancellation = ##f }\n' ,
  'noclefresize = { \override Staff.Clef #\'full-size-change = ##t }' ,
  # some room before starting the body
  '\markup {} \markup {} \markup {} \markup {} \n\n\n'
  ]

# Footer
footer = [
  '\n',
  '\n'
  ]

# aural intervals
auralIntervals = [ 'PP' , 'm2' , 'M2' , 'm3' , 'M3' , 'P4' , 'TT' , 'P5' , 'm6' , 'M6' , 'm7' , 'M7' , 'P8' ]

# clefs
clefs = [ 'treble' , 'treble' , 'treble' , 'treble' , 'treble' , 'treble' , 'treble' , 'treble' , 'bass' , 'bass' , 'bass' , 'bass' , 'bass' , 'bass' , 'alto' , 'tenor' ]

# Note Names
WrittenNoteNames = [ 'L-A' , 'L-B' , 'L-C' , 'L-D' , 'L-E' , 'L-F' , 'L-G' , 'S-A' , 'S-B' , 'S-C' , 'S-D' , 'S-E' , 'S-F' , 'S-G' ]
WrittenNoteNamesKeyTreble = [ "a''" , "b'" , "c'" , "d''" , "e'" , "f''" , "g'" , "a'" , "<b b''>" , "c''" , "d'" , "e''" , "f'" , "g''" ]
WrittenNoteNamesKeyBass = [ "a" , "b," , "c'" , "d" , "e," , "f" , "g," , "a," , "b" , "c" , "<d' d,>" , "e" , "f," , "g" ]
WrittenNoteNamesKeyAlto = [ "a" , "b'" , "c'" , "d" , "e'" , "f" , "g'" , "a'" , "b" , "<c'' c>" , "d'" , "e" , "f'" , "g" ]
WrittenNoteNamesKeyTenor = [ "a" , "b," , "c'" , "d" , "e'" , "f" , "g'" , "<a, a'>" , "b" , "c" , "d'" , "e" , "f'" , "g" ]
IdentifyNoteNamesTreble = [ "c'" , "d'" , "e'" , "f'" , "g'" , "a'" , "b'" , "c''" , "d''" , "e''" , "f''" , "g''" , "a''"  ]
IdentifyNoteNamesTrebleKey = [ 'C' , 'D' , 'E' , 'F' , 'G' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'A'  ]
IdentifyNoteNamesBass = [ "e," , "f," , "g," , "a," , "b," , "c" , "d" , "e" , "f" , "g" , "a" , "b" , "c'"  ]
IdentifyNoteNamesBassKey = [ 'E' , 'F' , 'G' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'A' , 'B' , 'C'  ]
IdentifyNoteNamesAlto = [ "d" , "e" , "f" , "g" , "a" , "b" , "c'" , "d'" , "e'" , "f'" , "g'" , "a'" , "b'" ]
IdentifyNoteNamesAltoKey = [ "D" , "E" , "F" , "G" , "A" , "B" , "C" , "D" , "E" , "F" , "G" , "A" , "B" ]
IdentifyNoteNamesTenor = [ "b," , "c" , "d" , "e" , "f" , "g" , "a" , "b" , "c'" , "d'" , "e'" , "f'" , "g'" ]
IdentifyNoteNamesTenorKey = [ "B" , "C" , "D" , "E" , "F" , "G" , "A" , "B" , "C" , "D" , "E" , "F" , "G" ]

# Durations
DurationSingleNoteEqualTo = [ "d'16 d'" , "d'8 d'16" , "d'8 d'" , "d'4 d'8" , "d'4 d'" , "d'2 d'4" , "d'2 d'" , "d'1 d'2" , "d'1 d'" , "d'16 d' d'" , "d'8 d'16 d'" , "d'4 d'16 d'" , "d'4 d'8 d'16" , "d'8 d' d'" , "d'4 d'8 d'" , "d'2 d'8 d'" , "d'2 d'4 d'8" , "d'4 d' d'" , "d'2 d'4 d'" , "d'1 d'4 d'" , "d'1 d'2 d'4" , "d'2 d' d'" , "d'16 d' d' d'" , "d'4 d'16 d' d'" , "d'8 d' d'16 d'" , "d'8 d' d' d'" , "d'2 d'8 d' d'" , "d'4 d' d'8 d'" , "d'4 d' d' d'" , "d'1 d'4 d' d'" , "d'2 d' d'4 d'" , "d'8. d'16" , "d'4. d'8" , "d'2. d'4" , "d'4. d'16" , "d'2. d'8" , "d'1. d'4" , "d'2. d'" , "d'4. d'" , "d'8. d'" , "d'16. d'" , "d'1 d'2." , "d'2 d'4." , "d'4 d'8." , "d'8 d'16." , "d'16~ d'" , "d'8~ d'16" , "d'8~ d'" , "d'4~ d'8" , "d'4~ d'" , "d'2~ d'4" , "d'2~ d'" , "d'1~ d'2" , "d'1~ d'" , "d'16~ d'~ d'" , "d'8~ d'16~ d'" , "d'4~ d'16~ d'" , "d'4~ d'8~ d'16" , "d'8~ d'~ d'" , "d'4~ d'8~ d'" , "d'2~ d'8~ d'" , "d'2~ d'4~ d'8" , "d'4~ d'~ d'" , "d'2~ d'4~ d'" , "d'1~ d'4~ d'" , "d'1~ d'2~ d'4" , "d'2~ d'~ d'" , "d'16~ d'~ d'~ d'" , "d'4~ d'16~ d'~ d'" , "d'8~ d'~ d'16~ d'" , "d'8~ d'~ d'~ d'" , "d'2~ d'8~ d'~ d'" , "d'4~ d'~ d'8~ d'" , "d'4~ d'~ d'~ d'" , "d'1~ d'4~ d'~ d'" , "d'2~ d'~ d'4~ d'" , "d'8.~ d'16" , "d'4.~ d'8" , "d'2.~ d'4" , "d'4.~ d'16" , "d'2.~ d'8" , "d'1.~ d'4" , "d'2.~ d'" , "d'4.~ d'" , "d'8.~ d'" , "d'16.~ d'" , "d'1~ d'2." , "d'2~ d'4." , "d'4~ d'8." , "d'8~ d'16." ]
DurationSingleNoteEqualToKey = [ "d'8" , "d'8." , "d'4" , "d'4." , "d'2" , "d'2." , "d'1" , "d'1." , "d'\\breve" , "d'8." , "d'4" , "d'4." , "d'4.." , "d'4." , "d'2" , "d'2." , "d'2.." , "d'2." , "d'1" , "d'1." , "d'1.." , "d'1." , "d'4" , "d'4.." , "d'4." , "d'2" , "d'2.." , "d'2." , "d'1" , "d'1.." , "d'1." , "d'4" , "d'2" , "d'1" , "d'4.." , "d'2.." , "d'1.." , "d'1." , "d'2." , "d'4." , "d'8." , "d'1.." , "d'2.." , "d'4.." , "d'8.." , "d'8" , "d'8." , "d'4" , "d'4." , "d'2" , "d'2." , "d'1" , "d'1." , "d'\\breve" , "d'8." , "d'4" , "d'4." , "d'4.." , "d'4." , "d'2" , "d'2." , "d'2.." , "d'2." , "d'1" , "d'1." , "d'1.." , "d'1." , "d'4" , "d'4.." , "d'4." , "d'2" , "d'2.." , "d'2." , "d'1" , "d'1.." , "d'1." , "d'4" , "d'2" , "d'1" , "d'4.." , "d'2.." , "d'1.." , "d'1." , "d'2." , "d'4." , "d'8." , "d'1.." , "d'2.." , "d'4.." , "d'8.." ]
DurationSingleRestEqualTo = [ "e'16\\rest e'\\rest" , "e'8\\rest e'16\\rest" , "e'8\\rest e'\\rest" , "e'4\\rest e'8\\rest" , "e'4\\rest e'\\rest" , "e'2\\rest e'4\\rest" , "e'2\\rest e'\\rest" , "e'1\\rest e'2\\rest" , "e'1\\rest e'\\rest" , "e'16\\rest e'\\rest e'\\rest" , "e'8\\rest e'16\\rest e'\\rest" , "e'4\\rest e'16\\rest e'\\rest" , "e'4\\rest e'8\\rest e'16\\rest" , "e'8\\rest e'\\rest e'\\rest" , "e'4\\rest e'8\\rest e'\\rest" , "e'2\\rest e'8\\rest e'\\rest" , "e'2\\rest e'4\\rest e'8\\rest" , "e'4\\rest e'\\rest e'\\rest" , "e'2\\rest e'4\\rest e'\\rest" , "e'1\\rest e'4\\rest e'\\rest" , "e'1\\rest e'2\\rest e'4\\rest" , "e'2\\rest e'\\rest e'\\rest" , "e'16\\rest e'\\rest e'\\rest e'\\rest" , "e'4\\rest e'16\\rest e'\\rest e'\\rest" , "e'8\\rest e'\\rest e'16\\rest e'\\rest" , "e'8\\rest e'\\rest e'\\rest e'\\rest" , "e'2\\rest e'8\\rest e'\\rest e'\\rest" , "e'4\\rest e'\\rest e'8\\rest e'\\rest" , "e'4\\rest e'\\rest e'\\rest e'\\rest" , "e'1\\rest e'4\\rest e'\\rest e'\\rest" , "e'2\\rest e'\\rest e'4\\rest e'\\rest" , "e'8.\\rest e'16\\rest" , "e'4.\\rest e'8\\rest" , "e'2.\\rest e'4\\rest" , "e'4.\\rest e'16\\rest" , "e'2.\\rest e'8\\rest" , "e'1.\\rest e'4\\rest" , "e'2.\\rest e'\\rest" , "e'4.\\rest e'\\rest" , "e'8.\\rest e'\\rest" , "e'16.\\rest e'\\rest" , "e'1\\rest e'2.\\rest" , "e'2\\rest e'4.\\rest" , "e'4\\rest e'8.\\rest" , "e'8\\rest e'16.\\rest" ]
DurationSingleRestEqualToKey = [ "e'8\\rest" , "e'8.\\rest" , "e'4\\rest" , "e'4.\\rest" , "e'2\\rest" , "e'2.\\rest" , "e'1\\rest" , "e'1.\\rest" , "e'\\breve\\rest" , "e'8.\\rest" , "e'4\\rest" , "e'4.\\rest" , "e'4..\\rest" , "e'4.\\rest" , "e'2\\rest" , "e'2.\\rest" , "e'2..\\rest" , "e'2.\\rest" , "e'1\\rest" , "e'1.\\rest" , "e'1..\\rest" , "e'1.\\rest" , "e'4\\rest" , "e'4..\\rest" , "e'4.\\rest" , "e'2\\rest" , "e'2..\\rest" , "e'2.\\rest" , "e'1\\rest" , "e'1..\\rest" , "e'1.\\rest" , "e'4\\rest" , "e'2\\rest" , "e'1\\rest" , "e'4..\\rest" , "e'2..\\rest" , "e'1..\\rest" , "e'1.\\rest" , "e'2.\\rest" , "e'4.\\rest" , "e'8.\\rest" , "e'1..\\rest" , "e'2..\\rest" , "e'4..\\rest" , "e'8..\\rest" ]
DurationTwoNotesEqualTo = [ "d'1." , "d'1" , "d'2." , "d'2" , "d'4." , "d'4" , "d'8." , "d'8" ]
DurationTwoNotesEqualToKey = [ "d'2." , "d'2" , "d'4." , "d'4" , "d'8." , "d'8" , "d'16." , "d'16" ]
DurationTwoRestsEqualTo = [ "e'1.\\rest" , "e'1\\rest" , "e'2.\\rest" , "e'2\\rest" , "e'4.\\rest" , "e'4\\rest" , "e'8.\\rest" , "e'8\\rest" ]
DurationTwoRestsEqualToKey = [ "e'2.\\rest" , "e'2\\rest" , "e'4.\\rest" , "e'4\\rest" , "e'8.\\rest" , "e'8\\rest" , "e'16.\\rest" , "e'16\\rest" ]
DurationThreeNotesEqualTo = [ "d'1." , "d'2." , "d'4." , "d'8." ]
DurationThreeNotesEqualToKey = [ "d'2" , "d'4" , "d'8" , "d'16" ]
DurationThreeRestsEqualTo = [ "e'1.\\rest" , "e'2.\\rest" , "e'4.\\rest" , "e'8.\\rest" ]
DurationThreeRestsEqualToKey = [ "e'2\\rest" , "e'4\\rest" , "e'8\\rest" , "e'16\\rest" ]
DurationComparisons = [ '1 whole note = ___ half notes' , '1 whole note = ___ quarter notes' , '1 whole note = ___ eighth notes' , '1 whole note = ___ sixteenth notes' , '2 whole notes = ___ half notes' , '2 whole notes = ___ quarter notes' , '2 whole notes = ___ eighth notes' , '3 whole notes = ___ half notes' , '3 whole notes = ___ quarter notes' , '4 whole notes = ___ half notes' , '1 half note = ___ quarter notes' , '1 half note = ___ eighth notes' , '1 half note = ___ sixteenth notes' , '2 half notes = ___ quarter notes' , '2 half notes = ___ eighth notes' , '2 half notes = ___ sixteenth notes' , '3 half notes = ___ quarter notes' , '3 half notes = ___ eighth notes' , '4 half notes = ___ quarter notes' , '1 quarter note = ___ eighth notes' , '1 quarter note = ___ sixteenth notes' , '2 quarter notes = ___ eighth notes' , '2 quarter notes = ___ sixteenth notes' , '3 quarter notes = ___ eighth notes' , '3 quarter notes = ___ sixteenth notes' , '4 quarter notes = ___ eighth notes' , '1 eighth note = ___ sixteenth notes' , '2 eighth notes = ___ sixteenth notes' , '3 eighth notes = ___ sixteenth notes' , '4 eighth notes = ___ sixteenth notes' , '2 sixteenth notes = ___ eighth notes' , '4 sixteenth notes = ___ eighth notes' , '6 sixteenth notes = ___ eighth notes' , '8 sixteenth notes = ___ eighth notes' , '4 sixteenth notes = ___ quarter notes' , '8 sixteenth notes = ___ quarter notes' , '8 sixteenth notes = ___ half notes' , '2 eighth notes = ___ quarter notes' , '4 eighth notes = ___ quarter notes' , '6 eighth notes = ___ quarter notes' , '8 eighth notes = ___ quarter notes' , '4 eighth notes = ___ half notes' , '8 eighth notes = ___ half notes' , '8 eighth notes = ___ whole notes' , '2 quarter notes = ___ half notes' , '4 quarter notes = ___ half notes' , '6 quarter notes = ___ half notes' , '8 quarter notes = ___ half notes' , '4 quarter notes = ___ whole notes' , '8 quarter notes = ___ whole notes' ]
DurationComparisonsKey = [ '1 whole note = \with-color #red 2 half notes' , '1 whole note = \with-color #red 4 quarter notes' , '1 whole note = \with-color #red 8 eighth notes' , '1 whole note = \with-color #red 16 sixteenth notes' , '2 whole notes = \with-color #red 4 half notes' , '2 whole notes = \with-color #red 8 quarter notes' , '2 whole notes = \with-color #red 16 eighth notes' , '3 whole notes = \with-color #red 6 half notes' , '3 whole notes = \with-color #red 12 quarter notes' , '4 whole notes = \with-color #red 8 half notes' , '1 half note = \with-color #red 2 quarter notes' , '1 half note = \with-color #red 4 eighth notes' , '1 half note = \with-color #red 8 sixteenth notes' , '2 half notes = \with-color #red 4 quarter notes' , '2 half notes = \with-color #red 8 eighth notes' , '2 half notes = \with-color #red 16 sixteenth notes' , '3 half notes = \with-color #red 6 quarter notes' , '3 half notes = \with-color #red 12 eighth notes' , '4 half notes = \with-color #red 8 quarter notes' , '1 quarter note = \with-color #red 2 eighth notes' , '1 quarter note = \with-color #red 4 sixteenth notes' , '2 quarter notes = \with-color #red 4 eighth notes' , '2 quarter notes = \with-color #red 8 sixteenth notes' , '3 quarter notes = \with-color #red 6 eighth notes' , '3 quarter notes = \with-color #red 12 sixteenth notes' , '4 quarter notes = \with-color #red 8 eighth notes' , '1 eighth note = \with-color #red 2 sixteenth notes' , '2 eighth notes = \with-color #red 4 sixteenth notes' , '3 eighth notes = \with-color #red 6 sixteenth notes' , '4 eighth notes = \with-color #red 8 sixteenth notes' , '2 sixteenth notes = \with-color #red 1 eighth notes' , '4 sixteenth notes = \with-color #red 2 eighth notes' , '6 sixteenth notes = \with-color #red 3 eighth notes' , '8 sixteenth notes = \with-color #red 4 eighth notes' , '4 sixteenth notes = \with-color #red 1 quarter notes' , '8 sixteenth notes = \with-color #red 2 quarter notes' , '8 sixteenth notes = \with-color #red 1 half notes' , '2 eighth notes = \with-color #red 1 quarter notes' , '4 eighth notes = \with-color #red 2 quarter notes' , '6 eighth notes = \with-color #red 3 quarter notes' , '8 eighth notes = \with-color #red 4 quarter notes' , '4 eighth notes = \with-color #red 1 half notes' , '8 eighth notes = \with-color #red 2 half notes' , '8 eighth notes = \with-color #red 1 whole notes' , '2 quarter notes = \with-color #red 1 half notes' , '4 quarter notes = \with-color #red 2 half notes' , '6 quarter notes = \with-color #red 3 half notes' , '8 quarter notes = \with-color #red 4 half notes' , '4 quarter notes = \with-color #red 1 whole notes' , '8 quarter notes = \with-color #red 2 whole notes' ]

# CST DST WT
IdentifyCstDstWtNotes = [ "ces''1 \\bar \"\" c''!" , "c''1 \\bar \"\" cis''" , "des''1 \\bar \"\" d''!" , "d''1 \\bar \"\" dis''" , "es''1 \\bar \"\" e''!" , "e''1 \\bar \"\" eis''" , "fes''1 \\bar \"\" f''!" , "f''1 \\bar \"\" fis''" , "ges'1 \\bar \"\" g'!" , "g'1 \\bar \"\" gis'" , "aes'1 \\bar \"\" a'!" , "a'1 \\bar \"\" ais'" , "bes'1 \\bar \"\" b'!" , "b'1 \\bar \"\" bis'" , "c''1 \\bar \"\" ces''" , "cis''1 \\bar \"\" c''!" , "d''1 \\bar \"\" des''" , "dis''1 \\bar \"\" d''!" , "e''1 \\bar \"\" es''" , "eis''1 \\bar \"\" e''!" , "f''1 \\bar \"\" fes''" , "fis''1 \\bar \"\" f''!" , "g'1 \\bar \"\" ges'" , "gis'1 \\bar \"\" g'!" , "a'1 \\bar \"\" aes'" , "ais'1 \\bar \"\" a'!" , "b'1 \\bar \"\" bes'" , "bis'1 \\bar \"\" b'!" , "c''1 \\bar \"\" des''" , "cis''1 \\bar \"\" d''" , "d''1 \\bar \"\" es''" , "dis''1 \\bar \"\" e''" , "es''1 \\bar \"\" fes''" , "e''1 \\bar \"\" f''" , "eis''1 \\bar \"\" fis''" , "f'1 \\bar \"\" ges'" , "fis'1 \\bar \"\" g'" , "g'1 \\bar \"\" aes'" , "gis'1 \\bar \"\" a'" , "a'1 \\bar \"\" bes'" , "ais'1 \\bar \"\" b'" , "bes'1 \\bar \"\" ces''" , "b'1 \\bar \"\" c''" , "bis'1 \\bar \"\" cis''" , "des''1 \\bar \"\" c''" , "d''1 \\bar \"\" cis''" , "es''1 \\bar \"\" d''" , "e''1 \\bar \"\" dis''" , "fes''1 \\bar \"\" es''" , "f''1 \\bar \"\" e''" , "fis''1 \\bar \"\" eis''" , "ges'1 \\bar \"\" f'" , "g'1 \\bar \"\" fis'" , "aes'1 \\bar \"\" g'" , "a'1 \\bar \"\" gis'" , "bes'1 \\bar \"\" a'" , "b'1 \\bar \"\" ais'" , "ces''1 \\bar \"\" bes'" , "c''1 \\bar \"\" b'" , "cis''1 \\bar \"\" bis'" , "ces''1 \\bar \"\" des''" , "c''1 \\bar \"\" d''" , "cis''1 \\bar \"\" dis''" , "des''1 \\bar \"\" es''" , "d''1 \\bar \"\" e''" , "dis''1 \\bar \"\" eis''" , "es''1 \\bar \"\" f''" , "e''1 \\bar \"\" fis''" , "fes'1 \\bar \"\" ges'" , "f'1 \\bar \"\" g'" , "fis'1 \\bar \"\" gis'" , "ges'1 \\bar \"\" aes'" , "g'1 \\bar \"\" a'" , "gis'1 \\bar \"\" ais'" , "aes'1 \\bar \"\" bes'" , "a'1 \\bar \"\" b'" , "ais'1 \\bar \"\" bis'" , "bes'1 \\bar \"\" c''" , "b'1 \\bar \"\" cis''" , "des''1 \\bar \"\" ces''" , "d''1 \\bar \"\" c''" , "dis''1 \\bar \"\" cis''" , "es''1 \\bar \"\" des''" , "e''1 \\bar \"\" d''" , "eis''1 \\bar \"\" dis''" , "f''1 \\bar \"\" es''" , "fis''1 \\bar \"\" e''" , "ges'1 \\bar \"\" fes'" , "g'1 \\bar \"\" f'" , "gis'1 \\bar \"\" fis'" , "aes'1 \\bar \"\" ges'" , "a'1 \\bar \"\" g'" , "ais'1 \\bar \"\" gis'" , "bes'1 \\bar \"\" aes'" , "b'1 \\bar \"\" a'" , "bis'1 \\bar \"\" ais'" , "c''1 \\bar \"\" bes'" , "cis''1 \\bar \"\" b'" ]
IdentifyCstDstWtNotesKey = [ "CST" , "CST" , "CST''" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "CST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "DST" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" , "WT" ]
WriteAboveCstNotes = [ "ces''1" , "c''1" , "des''1" , "d''1" , "es''1" , "e''1" , "fes''1" , "f''1" , "ges'1" , "g'1" , "aes'1" , "a'1" , "bes'1" , "b'1" ]
WriteAboveCstNotesKey = [ "ces''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red c''!" , "c''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red cis''" , "des''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red d''!" , "d''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red dis''" , "es''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red e''!" , "e''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red eis''" , "fes''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red f''!" , "f''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red fis''" , "ges'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red g'!" , "g'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red gis'" , "aes'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red a'!" , "a'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red ais'" , "bes'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red b'!" , "b'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red bis'" ]
WriteAboveDstNotes = [ "c''1" , "cis''1" , "d''1" , "dis''1" , "e''1" , "eis''1" , "f''1" , "fis''1" , "g'1" , "gis'1" , "a'1" , "ais'1" , "b'1" , "bis'1" ]
WriteAboveDstNotesKey = [ "c''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red des''" , "cis''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red d''" , "d''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red es''" , "dis''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red e''" , "e''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red f''" , "eis''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red fis''" , "f''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red ges''" , "fis''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red g''" , "g'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red aes'" , "gis'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red a'" , "a'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red bes'" , "ais'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red b'" , "b'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red c''" , "bis'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red cis''" ]
WriteAboveWtNotes = [ "ces''1" , "c''1" , "cis''1" , "des''1" , "d''1" , "es''1" , "e''1" , "fes''1" , "f''1" , "fis''1" , "ges'1" , "g'1" , "gis'1" , "aes'1" , "a'1" , "bes'1" , "b'1" ]
WriteAboveWtNotesKey = [ "ces''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red des''" , "c''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red d''" , "cis''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red dis''" , "des''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red es''" , "d''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red e''" , "es''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red f''" , "e''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red fis''" , "fes''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red ges''" , "f''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red g''" , "fis''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red gis''" , "ges'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red aes'" , "g'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red a'" , "gis'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red ais'" , "aes'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red bes'" , "a'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red b'" , "bes'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red c''" , "b'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red cis''" ]
WriteBelowCstNotes = WriteAboveDstNotes
WriteBelowCstNotesKey = [ "c''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red ces''" , "cis''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red c''!" , "d''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red des''" , "dis''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red d''!" , "e''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red es''" , "eis''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red e''!" , "f''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red fes''" , "fis''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red f''!" , "g'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red ges'" , "gis'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red g'!" , "a'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red aes'" , "ais'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red a'!" , "b'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red bes'" , "bis'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red b'!" ]
WriteBelowDstNotes = WriteAboveCstNotes
WriteBelowDstNotesKey = [ "ces''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red bes'" , "c''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red b'" , "des''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red c''" , "d''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red cis''" , "es''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red d''" , "e''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red dis''" , "fes''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red es''" , "f''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red e''" , "ges'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red f'" , "g'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red fis'" , "aes'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red g'" , "a'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red gis'" , "bes'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red a'" , "b'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red ais'" ]
WriteBelowWtNotes = [ "c''1" , "cis''1" , "des''1" , "d''1" , "dis''1" , "es''1" , "e''1" , "eis''1" , "f''1" , "fis''1" , "ges'1" , "g'1" , "gis'1" , "aes'1" , "a'1" , "ais'1" , "bes'1" , "b'1" , "bis'1" ]
WriteBelowWtNotesKey = [ "c''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red bes'" , "cis''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red b'" , "des''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red ces''" , "d''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red c''" , "dis''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red cis''" , "es''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red des''" , "e''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red d''" , "eis''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red dis''" , "f''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red es''" , "fis''1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red e''" , "ges'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red fes'" , "g'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red f'" , "gis'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red fis'" , "aes'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red ges'" , "a'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red g'" , "ais'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red gis'" , "bes'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red aes'" , "b'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red a'" , "bis'1 \\bar \"\" \once \override NoteHead #\'color = #red \once \override Accidental #'color = #red ais'" ]
EnharmonicNotes = [ 'C \\flat' , 'C' , 'C \sharp' , 'D \\flat' , 'D \sharp' , 'E \\flat' , 'E' , 'E \sharp' , 'F \\flat' , 'F' , 'F \sharp' , 'G \\flat' , 'G \sharp' , 'A \\flat' , 'A \sharp' , 'B \\flat' , 'B' , 'B \sharp' ]
EnharmonicNotesKey = [ 'B' , 'B \sharp' , 'D \\flat' , 'C \sharp' , 'E \\flat' , 'D \sharp' , 'F \\flat' , 'F' , 'E' , 'E \sharp' , 'G \\flat' , 'A \sharp' , 'A \\flat' , 'G \sharp' , 'B \\flat' , 'A \sharp' , 'C \\flat' , 'C' ]

# Circle of fifths
CircleOfFifths = [
  '\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { \large \\bold "Draw a circle of fifths in the space provided." }} \\noPageBreak \n',
  '\markup { \\vspace #15 }\n\n' ]
CircleOfFifthsKey = [
  '\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { \large \\bold "Draw a circle of fifths in the space provided." }} \\noPageBreak \n',
  '\markup { \general-align #Y #DOWN { \epsfile #Y #50 #"/usr/share/rudi/cof.eps" }}\n\n' ]
# Key Signatures
MajKeySigList = [ 'C \\flat Maj.' , 'G \\flat Maj.' , 'D \\flat Maj.' , 'A \\flat Maj.' , 'E \\flat Maj.' , 'B \\flat Maj.' , 'F Maj.' , 'C Maj.' , 'G Maj.' , 'D Maj.' , 'A Maj.' , 'E Maj.' , 'B Maj.' , 'F \sharp Maj.' , 'C \sharp Maj.' ]
MajKeySigListKey = [ 'ces' , 'ges' , 'des' , 'aes' , 'es' , 'bes' , 'f' , 'c' , 'g' , 'd' , 'a' , 'e' , 'b' , 'fis' , 'cis' ]
MinKeySigList = [ 'A \\flat min.' , 'E \\flat min.' , 'B \\flat min.' , 'F min.' , 'C min.' , 'G min.' , 'D min.' , 'A min.' , 'E min.' , 'B min.' , 'F \sharp min.' , 'C \sharp min.' , 'G \sharp min.' , 'D \sharp min.' , 'A \sharp min.' ]
MinKeySigListKey = [ 'aes' , 'es' , 'bes' , 'f' , 'c' , 'g' , 'd' , 'a' , 'e' , 'b' , 'fis' , 'cis' , 'gis' , 'dis' , 'ais' ]

# scale degrees
ScaleDegreeList = [ 'tonic (I)' , 'supertonic (ii)' , 'mediant (iii)' , 'subdominant (IV)' , 'dominant (V)' , 'submediant (vi)' , 'leading tone (vii)' ]
ScaleDegreeDictKey = { 'C \\flat Maj.': [ 'C \\flat' , 'D \\flat' , 'E \\flat' , 'F \\flat' , 'G \\flat' , 'A \\flat' , 'B \\flat' ] , 'G \\flat Maj.': [ 'G \\flat' , 'A \\flat' , 'B \\flat' , 'C \\flat' , 'D \\flat' , 'E \\flat' , 'F' ] , 'D \\flat Maj.': [ 'D \\flat' , 'E \\flat' , 'F' , 'G \\flat' , 'A \\flat' , 'B \\flat' , 'C' ] , 'A \\flat Maj.': [ 'A \\flat' , 'B \\flat' , 'C' , 'D \\flat' , 'E \\flat' , 'F' , 'G'   ] , 'E \\flat Maj.': [ 'E \\flat' , 'F' , 'G' , 'A \\flat' , 'B \\flat' , 'C' , 'D'   ] , 'B \\flat Maj.': [ 'B \\flat' , 'C' , 'D' , 'E \\flat' , 'F' , 'G' , 'A'   ] , 'F Maj.': [ 'F' , 'G' , 'A' , 'B \\flat' , 'C' , 'D' , 'E'   ] , 'C Maj.': [  'C' , 'D' , 'E' , 'F' , 'G' , 'A' , 'B' ] , 'G Maj.': [ 'G' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F \sharp' ] , 'D Maj.': [ 'D' , 'E' , 'F \sharp' , 'G' , 'A' , 'B' , 'C \sharp' ] , 'A Maj.': [ 'A' , 'B' , 'C \sharp' , 'D' , 'E' , 'F \sharp' , 'G \sharp' ] , 'E Maj.': [ 'E' , 'F \sharp' , 'G \sharp' , 'A' , 'B' , 'C \sharp' , 'D \sharp' ] , 'B Maj.': [ 'B' , 'C \sharp' , 'D \sharp' , 'E' , 'F \sharp' , 'G \sharp' , 'A \sharp' ] , 'F \sharp Maj.': [ 'F \sharp' , 'G \sharp' , 'A \sharp' , 'B' , 'C \sharp' , 'D \sharp' , 'E \sharp' ] , 'C \sharp Maj.': [ 'C \sharp' , 'D \sharp' , 'E \sharp' , 'F \sharp' , 'G \sharp' , 'A \sharp' , 'B \sharp' ]  }

# Scales
MinorScales = [ 'Natural Minor' , 'Harmonic Minor' , 'Melodic Minor' ]
WrittenMajorStartingNotes = [ 'a C \\flat' , 'a G \\flat' , 'a D \\flat' , 'an A \\flat' , 'an E \\flat' , 'a B \\flat' , 'a F' , 'a C' , 'a G' , 'a D' , 'an A' , 'an E' , 'a B' , 'a F \\sharp' , 'a C \\sharp' ]
WrittenMinorStartingNotes = [ 'an A \\flat' , 'an E \\flat' , 'a B \\flat' , 'a F' , 'a C' , 'a G' , 'a D' , 'an A' , 'an E' , 'a B' , 'a F \\sharp' , 'a C \\sharp' , 'a G \\sharp' , 'a D \\sharp' , 'an A \\sharp' ]
IdentifyMajorScales = { 0 : 'ces1 des es fes ges aes bes ces', 1 : 'ges1 aes bes ces des es f ges', 2 : 'des1 es f ges aes bes c des', 3 : 'aes1 bes c des es f g aes', 4 : 'es1 f g aes bes c d es', 5 : 'bes1 c d es f g a bes', 6 : 'f1 g a bes c d e f', 7 : 'c1 d e f g a b c', 8 : 'g1 a b c d e fis g', 9 : 'd1 e fis g a b cis d', 10 : 'a1 b cis d e fis gis a', 11 : 'e1 fis gis a b cis dis e', 12 : 'b1 cis dis e fis gis ais b', 13 : 'fis1 gis ais b cis dis eis fis', 14 : 'cis1 dis eis fis gis ais bis cis' }
IdentifyMinorScales = { 0 : 'aes1 bes ces des es fes ges aes', 1 : 'aes1 bes ces des es fes g aes', 2 : 'aes1 bes ces des es f g aes', 3 : 'es1 f ges aes bes ces des es', 4 : 'es1 f ges aes bes ces d es' , 5 : 'es1 f ges aes bes c d es' , 6 : 'bes1 c des es f ges aes bes' , 7 : 'bes1 c des es f ges a bes' , 8 : 'bes1 c des es f g a bes' , 9 : 'f1 g aes bes c des es f' , 10 : 'f1 g aes bes c des e f' , 11 : 'f1 g aes bes c d e f' , 12 : 'c1 d es f g aes bes c' , 13 : 'c1 d es f g aes b c' , 14 : 'c1 d es f g a b c' , 15 : 'g1 a bes c d es f g' , 16 : 'g1 a bes c d es fis g' , 17 : 'g1 a bes c d e fis g' , 18 : 'd1 e f g a bes c d' , 19 : 'd1 e f g a bes cis d' , 20 : 'd1 e f g a b cis d' , 21 : 'a1 b c d e f g a' , 22 : 'a1 b c d e f gis a' , 23 : 'a1 b c d e fis gis a' , 24 : 'e1 fis g a b c d e' , 25 : 'e1 fis g a b c dis e' , 26 : 'e1 fis g a b cis dis e' , 27 : 'b1 cis d e fis g a b' , 28 : 'b1 cis d e fis g ais b' , 29 : 'b1 cis d e fis gis ais b' , 30 : 'fis1 gis a b cis d e fis' , 31 : 'fis1 gis a b cis d eis fis' , 32 : 'fis1 gis a b cis dis eis fis' , 33 : 'cis1 dis e fis gis a b cis' , 34 : 'cis1 dis e fis gis a bis cis' , 35 : 'cis1 dis e fis gis ais bis cis' , 36 : 'gis1 ais b cis dis e fis gis' , 37 : 'gis1 ais b cis dis e fisis gis' , 38 : 'gis1 ais b cis dis eis fisis gis' , 39 : 'dis1 eis fis gis ais b cis dis' , 40 : 'dis1 eis fis gis ais b cisis dis' , 41 : 'dis1 eis fis gis ais bis cisis dis' , 42 : 'ais1 bis cis dis eis fis gis ais' , 43 : 'ais1 bis cis dis eis fis gisis ais' , 44 : 'ais1 bis cis dis eis fisis gisis ais' }
MinorScalesKey = { 0 : 'aes1 bes ces des es fes ges aes', 1 : 'aes1 bes ces des es fes g aes', 2 : 'aes1 bes ces des es f g aes ges! fes! es des ces bes aes', 3 : 'es1 f ges aes bes ces des es', 4 : 'es1 f ges aes bes ces d es' , 5 : 'es1 f ges aes bes c d es des! ces! bes aes ges f es' , 6 : 'bes1 c des es f ges aes bes' , 7 : 'bes1 c des es f ges a bes' , 8 : 'bes1 c des es f g a bes aes! ges! f es des c bes' , 9 : 'f1 g aes bes c des es f' , 10 : 'f1 g aes bes c des e f' , 11 : 'f1 g aes bes c d e f es! des! c bes aes g f' , 12 : 'c1 d es f g aes bes c' , 13 : 'c1 d es f g aes b c' , 14 : 'c1 d es f g a b c bes! aes! g f es d c' , 15 : 'g1 a bes c d es f g' , 16 : 'g1 a bes c d es fis g' , 17 : 'g1 a bes c d e fis g f! es! d c bes a g' , 18 : 'd1 e f g a bes c d' , 19 : 'd1 e f g a bes cis d' , 20 : 'd1 e f g a b cis d c! bes! a g f e d' , 21 : 'a1 b c d e f g a' , 22 : 'a1 b c d e f gis a' , 23 : 'a1 b c d e fis gis a g! f! e d c b a' , 24 : 'e1 fis g a b c d e' , 25 : 'e1 fis g a b c dis e' , 26 : 'e1 fis g a b cis dis e d! c! b a g fis e' , 27 : 'b1 cis d e fis g a b' , 28 : 'b1 cis d e fis g ais b' , 29 : 'b1 cis d e fis gis ais b a! g! fis e d cis b' , 30 : 'fis1 gis a b cis d e fis' , 31 : 'fis1 gis a b cis d eis fis' , 32 : 'fis1 gis a b cis dis eis fis e! d! cis b a gis fis' , 33 : 'cis1 dis e fis gis a b cis' , 34 : 'cis1 dis e fis gis a bis cis' , 35 : 'cis1 dis e fis gis ais bis cis b! a! gis fis e dis cis' , 36 : 'gis1 ais b cis dis e fis gis' , 37 : 'gis1 ais b cis dis e fisis gis' , 38 : 'gis1 ais b cis dis eis fisis gis fis! e! dis cis b ais gis' , 39 : 'dis1 eis fis gis ais b cis dis' , 40 : 'dis1 eis fis gis ais b cisis dis' , 41 : 'dis1 eis fis gis ais bis cisis dis cis! b! ais gis fis eis dis' , 42 : 'ais1 bis cis dis eis fis gis ais' , 43 : 'ais1 bis cis dis eis fis gisis ais' , 44 : 'ais1 bis cis dis eis fisis gisis ais gis! fis! eis dis cis bis ais' }
ChrOctWTScales = [ 'Chromatic' , 'Wholetone' , 'Octatonic' ]
OctatonicChoice = [ 'semitone first' , 'wholetone first' ]
ChromaticWrittenStartingNotes = [ 'a C \\flat' , 'a C' , 'a C \\sharp' , 'a D \\flat' , 'a D' , 'a D \\sharp' , 'an E \\flat' , 'an E' , 'an E \\sharp' , 'a F \\flat' , 'a F' , 'a F \\sharp' , 'a G \\flat' , 'a G' , 'a G \\sharp' , 'an A \\flat' , 'an A' , 'an A \\sharp' , 'a B \\flat' , 'a B' , 'a B \\sharp' ]
ChromaticScalesKey = [ 'ces1 c! des d! es e! f fis g gis a bes ces \\bar "|" bes! a aes g ges f e es d des c ces \\bar "|"' , 'c1 cis d dis e f fis g gis a ais b c \\bar "|" b bes a aes g ges f e es d des c \\bar "|"' , 'cis1 d dis e f fis g gis a ais b bis cis \\bar "|" c b bes a aes g ges f e es d cis \\bar "|"' , 'des1 d! es e! f fis g gis a ais b c des \\bar "|" c b bes a aes g ges f e es d des \\bar "|"' , 'd1 dis e f fis g gis a ais b c cis d \\bar "|" des c b bes a aes g ges f e es d \\bar "|"' , 'dis1 e f fis g gis a ais b bis cis cisis dis \\bar "|" d cis c! b bes a aes g ges f e dis \\bar "|"' , 'es1 e! f fis g gis a ais b c cis d es \\bar "|" d des c b bes a aes g ges f e es \\bar "|"' , 'e1 f fis g gis a ais b c cis d dis e \\bar "|" es d des c b bes a aes g ges f e \\bar "|"', 'eis1 fis g gis a ais b bis cis cisis dis disis eis \\bar "|" e dis d! cis c! b bes a aes g fis eis \\bar "|"' , 'fes1 f! ges g! aes a! bes b! c cis d es fes \\bar "|" es d des c b bes a aes g ges f fes \\bar "|"' , 'f1 fis g gis a ais b c cis d dis e f \\bar "|" e es d des c b bes a aes g ges f \\bar "|"' , 'fis1 g gis a ais b c cis d dis e eis fis \\bar "|" f e es d des c b bes a aes g fis \\bar "|"' , 'ges1 g! aes a! bes b! c cis d dis e f ges \\bar "|" f e es d des c b bes a aes g ges \\bar "|"' , 'g1 gis a ais b c cis d dis e f fis g \\bar "|" ges f e es d des c b bes a aes g \\bar "|"' , 'gis1 a ais b c cis d dis e eis fis fisis gis \\bar "|" g fis f! e es d des c b bes a gis \\bar "|"' , 'aes1 a! bes b! c cis d dis e f fis g aes \\bar "|" g ges f e es d des c b bes a aes \\bar "|"' , 'a1 ais b c cis d dis e f fis g gis a \\bar "|" aes g ges f e es d des c b bes a \\bar "|"' , 'ais1 b c cis d dis e eis fis fisis gis gisis ais \\bar "|" a gis g! fis f! e es d des c b ais \\bar "|"' , 'bes1 b! c cis d dis e f fis g gis a bes \\bar "|" a aes g ges f e es d des c b bes \\bar "|"' , 'b1 c cis d dis e f fis g gis a ais b \\bar "|" bes a aes g ges f e es d des c b \\bar "|"' , 'bis1 cis d dis e eis fis fisis gis gisis ais aisis bis \\bar "|" b ais a! gis g! fis f! e es d cis bis \\bar "|"' ]
IdentifyChromaticScales = [ 'ces1 c des d es e f fis g gis a bes ces' , 'c1 cis d dis e f fis g gis a ais b c' , 'cis1 d dis e f fis g gis a ais b c cis' , 'des1 d es e f fis g gis a ais b c des' , 'd1 dis e f fis g gis a ais b c cis d' , 'dis1 e f fis g gis a ais b c cis d dis' , 'es1 e f fis g gis a ais b c cis d es' , 'e1 f fis g gis a ais b c cis d dis e', 'eis1 fis g gis a ais b c cis d dis e eis' , 'fes1 f ges g aes a bes b c cis d dis fes' , 'f1 fis g gis a ais b c cis d dis e f' , 'fis1 g gis a ais b c cis d dis e f fis' , 'ges1 g aes a bes b c cis d dis e f ges' , 'g1 gis a ais b c cis d dis e f fis g' , 'gis1 a ais b c cis d dis e f fis g gis' , 'aes1 a bes b c cis d dis e f fis g aes' , 'a1 ais b c cis d dis e f fis g gis a' , 'ais1 b c cis d dis e f fis g gis a ais' , 'bes1 b c cis d dis e f fis g gis a bes' , 'b1 c cis d dis e f fis g gis a ais b' , 'bis1 cis d dis e f fis g gis a ais b bis' ]
IdentifyWholetoneScales = [ 'ces1 des es f g a ces' , 'c1 d e fis gis ais c' , 'cis1 dis f g a b cis' , 'des1 es f g a b des' , 'd1 e fis gis ais c d' , 'dis1 f g a b cis dis' , 'es1 f g a b des es' , 'e1 fis gis ais c d e' , 'eis1 g a b cis dis eis' , 'fes1 ges aes bes c d fes' , 'f1 g a b cis dis f' , 'fis1 gis ais c d e fis' , 'ges1 aes bes c d e ges' , 'g1 a b cis dis f g' , 'gis1 ais c d e fis gis' , 'aes1 bes c d e ges aes' , 'a1 b cis dis f g a' , 'ais1 c d e fis gis ais' , 'bes1 c d e fis gis bes' , 'b1 cis dis f g a b' , 'bis1 d e fis gis ais bis' ]
IdentifyOctatonicScales = [ 'ces1 c! d es f ges aes a ces' , 'ces1 des d! e f g aes bes ces' , 'c1 des es e! fis g a bes c' , 'c1 d es f ges aes a! b c' , 'cis1 d e f g aes bes b! cis' , 'cis1 dis e fis g a bes c cis' , 'des1 d! e f g aes bes ces des' , 'des1 es e! fis g a bes c des' , 'd1 es f ges aes a! ces c d' , 'd1 e f g aes bes ces des d!' , 'dis1 e fis g a bes c cis dis' , 'dis1 f ges aes a! ces c! d dis' , 'es1 e! fis g a bes c des es' , 'es1 f ges aes a! b c d es' , 'e1 f g aes bes ces des d! e' , 'e1 fis g a bes c des es e!' , 'eis1 fis gis a b c d dis eis' , 'eis1 g aes bes ces des d! e eis' , 'fes1 f! g aes bes ces des d! fes' , 'fes1 ges g! a bes c des es fes' , 'f1 fis gis a b c d dis f' , 'f1 g aes bes ces des d! e f' , 'fis1 g a bes c des es e! fis' , 'fis1 gis a b c d dis f fis' , 'ges1 g! a bes c des es fes ges' , 'ges1 aes a! b c d es f ges' , 'g1 aes bes ces des d! e f g' , 'g1 a bes c des es e! fis g' , 'gis1 a b c d es f fis gis' , 'gis1 ais b cis d e f g gis' , 'aes1 a! b c d es f ges aes' , 'aes1 bes ces des d! e f g aes' , 'a1 bes c des es e! fis g a' , 'a1 b c d es f ges aes a!' , 'ais1 b cis d e f g gis ais' , 'ais1 c des es e! fis g a ais' , 'bes1 b! cis d e f g aes bes' , 'bes1 c des es e! fis g a bes' , 'b1 c d es f ges aes a! b' , 'b1 cis d e f g aes bes b!' , 'bis1 cis dis e fis g a ais bis' , 'bis1 d dis f fis gis a b bis' ]
IdentifyOctatonicScalesKey = [ 'C \\flat Octatonic Semitone First' , 'C \\flat Octatonic Wholetone First' , 'C Octatonic Semitone First' , 'C Octatonic Wholetone First' , 'C \sharp Octatonic Semitone First' , 'C \sharp Octatonic Wholetone First' , 'D \\flat Octatonic Semitone First' , 'D \\flat Octatonic Wholetone First' , 'D Octatonic Semitone First' , 'D Octatonic Wholetone First' , 'D \sharp Octatonic Semitone First' , 'D \sharp Octatonic Wholetone First' , 'E \\flat Octatonic Semitone First' , 'E \\flat Octatonic Wholetone First' , 'E Octatonic Semitone First' , 'E Octatonic Wholetone First' , 'E \sharp Octatonic Semitone First' , 'E \sharp Octatonic Wholetone First' , 'F \\flat Octatonic Semitone First' , 'F \\flat Octatonic Wholetone First' , 'F Octatonic Semitone First' , 'F Octatonic Wholetone First' , 'F \sharp Octatonic Semitone First' , 'F \sharp Octatonic Wholetone First' , 'G \\flat Octatonic Semitone First' , 'G \\flat Octatonic Wholetone First' , 'G Octatonic Semitone First' , 'G Octatonic Wholetone First' , 'G \sharp Octatonic Semitone First' , 'G \sharp Octatonic Wholetone First' , 'A \\flat Octatonic Semitone First' , 'A \\flat Octatonic Wholetone First' , 'A Octatonic Semitone First' , 'A Octatonic Wholetone First' , 'A \sharp Octatonic Semitone First' , 'A \sharp Octatonic Wholetone First' , 'B \\flat Octatonic Semitone First' , 'B \\flat Octatonic Wholetone First' , 'B Octatonic Semitone First' , 'B Octatonic Wholetone First' , 'B \sharp Octatonic Semitone First' , 'B \sharp Octatonic Wholetone First' ]
MajorPentScaleWrittenStartingNotes = WrittenMajorStartingNotes
MinorPentScaleWrittenStartingNotes = WrittenMinorStartingNotes
BluesScaleWrittenStartingNotes = WrittenMinorStartingNotes
IdentifyMajorPentScales = { 0 : 'ces1 des es ges aes ces', 1 : 'ges1 aes bes des es ges', 2 : 'des1 es f aes bes des', 3 : 'aes1 bes c es f aes', 4 : 'es1 f g bes c es', 5 : 'bes1 c d f g bes', 6 : 'f1 g a c d f', 7 : 'c1 d e g a c', 8 : 'g1 a b d e g', 9 : 'd1 e fis a b d', 10 : 'a1 b cis e fis a', 11 : 'e1 fis gis b cis e', 12 : 'b1 cis dis fis gis b', 13 : 'fis1 gis ais cis dis fis', 14 : 'cis1 dis eis gis ais cis' }
IdentifyMinorPentScales = { 0 : 'aes1 ces des es ges aes', 3 : 'es1 ges aes bes des es', 6 : 'bes1 des es f aes bes' , 9 : 'f1 aes bes c es f' , 12 : 'c1 es f g bes c' , 15 : 'g1 bes c d f g' , 18 : 'd1 f g a c d' , 21 : 'a1 c d e g a' , 24 : 'e1 g a b d e' , 27 : 'b1 d e fis a b' , 30 : 'fis1 a b cis e fis' , 33 : 'cis1 e fis gis b cis' , 36 : 'gis1 b cis dis fis gis' , 39 : 'dis1 fis gis ais cis dis' , 42 : 'ais1 cis dis eis gis ais' }
IdentifyBluesScales = { 0 : 'aes1 ces des d es ges aes', 3 : 'es1 ges aes a bes des es', 6 : 'bes1 des es e f aes bes' , 9 : 'f1 aes bes b c es f' , 12 : 'c1 es f fis g bes c' , 15 : 'g1 bes c cis d f g' , 18 : 'd1 f g gis a c d' , 21 : 'a1 c d dis e g a' , 24 : 'e1 g a ais b d e' , 27 : 'b1 d e eis fis a b' , 30 : 'fis1 a b bis cis e fis' , 33 : 'cis1 e fis fisis gis b cis' , 36 : 'gis1 b cis cisis dis fis gis' , 39 : 'dis1 fis gis gisis ais cis dis' , 42 : 'ais1 cis dis disis eis gis ais' }
ModesScales = { 0 : 'a C Ionian' , 1 : 'a D Dorian' , 2 : 'an E Phrygian' , 3 : 'a F Lydian' , 4 : 'a G Mixolydian' , 5 : 'an A Aeolian' , 6 : 'a B Locrian' , 7 : 'a G Ionian' , 8 : 'an A Dorian' , 9 : 'a B Phrygian' , 10 : 'a C Lydian' , 11 : 'a D Mixolydian' , 12 : 'an E Aeolian' , 13 : 'a F \sharp Locrian' , 14 : 'a D Ionian' , 15 : 'an E Dorian' , 16 : 'a F \sharp Phrygian' , 17 : 'a G Lydian' , 18 : 'an A Mixolydian' , 19 : 'a B Aeolian' , 20 : 'a C \sharp Locrian' , 21 : 'an A Ionian' , 22 : 'a B Dorian' , 23 : 'a C \sharp Phrygian' , 24 : 'a D Lydian' , 25 : 'an E Mixolydian' , 26 : 'a F \sharp Aeolian' , 27 : 'a G \sharp Locrian' , 28 : 'an E Ionian' , 29 : 'a F \sharp Dorian' , 30 : 'a G \sharp Phrygian' , 31 : 'an A Lydian' , 32 : 'a B Mixolydian' , 33 : 'a C \sharp Aeolian' , 34 : 'a D \sharp Locrian' , 35 : 'a B Ionian' , 36 : 'a C \sharp Dorian' , 37 : 'a D \sharp Phrygian' , 38 : 'an E Lydian' , 39 : 'a F \sharp Mixolydian' , 40 : 'a G \sharp Aeolian' , 41 : 'an A \sharp Locrian' , 42 : 'a F \sharp Ionian' , 43 : 'a G \sharp Dorian' , 44 : 'an A \sharp Phrygian' , 45 : 'a B Lydian' , 46 : 'a C \sharp Mixolydian' , 47 : 'a D \sharp Aeolian' , 48 : 'an E \sharp Locrian' , 49 : 'a C \sharp Ionian' , 50 : 'a D \sharp Dorian' , 51 : 'an E \sharp Phrygian' , 52 : 'a F \sharp Lydian' , 53 : 'a G \sharp Mixolydian' , 54 : 'an A \sharp Aeolian' , 55 : 'a B \sharp Locrian' , 56 : 'a F Ionian' , 57 : 'a G Dorian' , 58 : 'an A Phrygian' , 59 : 'a B \\flat Lydian' , 60 : 'a C Mixolydian' , 61 : 'a D Aeolian' , 62 : 'an E Locrian' , 63 : 'a B \\flat Ionian' , 64 : 'a C Dorian' , 65 : 'a D Phrygian' , 66 : 'an E \\flat Lydian' , 67 : 'a F Mixolydian' , 68 : 'a G Aeolian' , 69 : 'an A Locrian' , 70 : 'an E \\flat Ionian' , 71 : 'a F Dorian' , 72 : 'a G Phrygian' , 73 : 'an A \\flat Lydian' , 74 : 'a B \\flat Mixolydian' , 75 : 'a C Aeolian' , 76 : 'a D Locrian' , 77 : 'an A \\flat Ionian' , 78 : 'a B \\flat Dorian' , 79 : 'a C Phrygian' , 80 : 'a D \\flat Lydian' , 81 : 'an E \\flat Mixolydian' , 82 : 'a F Aeolian' , 83 : 'a G Locrian' , 84 : 'a D \\flat Ionian' , 85 : 'an E \\flat Dorian' , 86 : 'a F Phrygian' , 87 : 'a G \\flat Lydian' , 88 : 'an A \\flat Mixolydian' , 89 : 'a B \\flat Aeolian' , 90 : 'a C Locrian' , 91 : 'a G \\flat Ionian' , 92 : 'an A \\flat Dorian' , 93 : 'a B \\flat Phrygian' , 94 : 'a C \\flat Lydian' , 95 : 'a D \\flat Mixolydian' , 96 : 'an E \\flat Aeolian' , 97 : 'a F Lorian' , 98 : 'a C \\flat Ionian' , 99 : 'a D \\flat Dorian' , 100 : 'an E \\flat Phrygian' , 101 : 'a F \\flat Lydian' , 102 : 'a G \\flat Mixolydian' , 103 : 'an A \\flat Aeolian' , 104 : 'a B \\flat Locrian' }
IdentifyModeScales = { 0 : 'c1 d e f g a b c' , 1 : 'd1 e f g a b c d' , 2 : 'e1 f g a b c d e' , 3 : 'f1 g a b c d e f' , 4 : 'g1 a b c d e f g' , 5 : 'a1 b c d e f g a' , 6 : 'b1 c d e f g a b' , 7 : 'g1 a b c d e fis g' , 8 : 'a1 b c d e fis g a' , 9 : 'b1 c d e fis g a b' , 10 : 'c1 d e fis g a b c' , 11 : 'd1 e fis g a b c d' , 12 : 'e1 fis g a b c d e' , 13 : 'fis1 g a b c d e fis' , 14 : 'd1 e fis g a b cis d' , 15 : 'e1 fis g a b cis d e' , 16 : 'fis1 g a b cis d e fis' , 17 : 'g1 a b cis d e fis g' , 18 : 'a1 b cis d e fis g a' , 19 : 'b1 cis d e fis g a b' , 20 : 'cis1 d e fis g a b cis' , 21 : 'a1 b cis d e fis gis a' , 22 : 'b1 cis d e fis gis a b' , 23 : 'cis1 d e fis gis a b cis' , 24 : 'd1 e fis gis a b cis d' , 25 : 'e1 fis gis a b cis d e' , 26 : 'fis1 gis a b cis d e fis' , 27 : 'gis1 a b cis d e fis gis' , 28 : 'e1 fis gis a b cis dis e' , 29 : 'fis1 gis a b cis dis e fis' , 30 : 'gis1 a b cis dis e fis gis' , 31 : 'a1 b cis dis e fis gis a' , 32 : 'b1 cis dis e fis gis a b' , 33 : 'cis1 dis e fis gis a b cis' , 34 : 'dis1 e fis gis a b cis dis' , 35 : 'b1 cis dis e fis gis ais b' , 36 : 'cis1 dis e fis gis ais b cis' , 37 : 'dis1 e fis gis ais b cis dis' , 38 : 'e1 fis gis ais b cis dis e' , 39 : 'fis1 gis ais b cis dis e fis' , 40 : 'gis1 ais b cis dis e fis gis' , 41 : 'ais1 b cis dis e fis gis ais' , 42 : 'fis1 gis ais b cis dis eis fis' , 43 : 'gis1 ais b cis dis eis fis gis' , 44 : 'ais1 b cis dis eis fis gis ais' , 45 : 'b1 cis dis eis fis gis ais b' , 46 : 'cis1 dis eis fis gis ais b cis' , 47 : 'dis1 eis fis gis ais b cis dis' , 48 : 'eis1 fis gis ais b cis dis eis' , 49 : 'cis1 dis eis fis gis ais bis cis' , 50 : 'dis1 eis fis gis ais bis cis dis' , 51 : 'eis1 fis gis ais bis cis dis eis' , 52 : 'fis1 gis ais bis cis dis eis fis' , 53 : 'gis1 ais bis cis dis eis fis gis' , 54 : 'ais1 bis cis dis eis fis gis ais' , 55 : 'bis1 cis dis eis fis gis ais bis' , 56 : 'f1 g a bes c d e f' , 57 : 'g1 a bes c d e f g' , 58 : 'a1 bes c d e f g a' , 59 : 'bes1 c d e f g a bes' , 60 : 'c1 d e f g a bes c' , 61 : 'd1 e f g a bes c d' , 62 : 'e1 f g a bes c d e' , 63 : 'bes1 c d es f g a bes' , 64 : 'c1 d es f g a bes c' , 65 : 'd1 es f g a bes c d' , 66 : 'es1 f g a bes c d es' , 67 : 'f1 g a bes c d es f' , 68 : 'g1 a bes c d es f g' , 69 : 'a1 bes c d es f g a' , 70 : 'es1 f g aes bes c d es' , 71 : 'f1 g aes bes c d es f' , 72 : 'g1 aes bes c d es f g' , 73 : 'aes1 bes c d es f g aes' , 74 : 'bes1 c d es f g aes bes' , 75 : 'c1 d es f g aes bes c' , 76 : 'd1 es f g aes bes c d' , 77 : 'aes1 bes c des es f g aes' , 78 : 'bes1 c des es f g aes bes' , 79 : 'c1 des es f g aes bes c' , 80 : 'des1 es f g aes bes c des' , 81 : 'es1 f g aes bes c des es' , 82 : 'f1 g aes bes c des es f' , 83 : 'g1 aes bes c des es f g' , 84 : 'des1 es f ges aes bes c des' , 85 : 'es1 f ges aes bes c des es' , 86 : 'f1 ges aes bes c des es f' , 87 : 'ges1 aes bes c des es f ges' , 88 : 'aes1 bes c des es f ges aes' , 89 : 'bes1 c des es f ges aes bes' , 90 : 'c1 des es f ges aes bes c' , 91 : 'ges1 aes bes ces des es f ges' , 92 : 'aes1 bes ces des es f ges aes' , 93 : 'bes1 ces des es f ges aes bes' , 94 : 'ces1 des es f ges aes bes ces' , 95 : 'des1 es f ges aes bes ces des' , 96 : 'es1 f ges aes bes ces des es' , 97 : 'f1 ges aes bes ces des es f' , 98 : 'ces1 des es fes ges aes bes ces' , 99 : 'des1 es fes ges aes bes ces des' , 100 : 'es1 fes ges aes bes ces des es' , 101 : 'fes1 ges aes bes ces des es fes' , 102 : 'ges1 aes bes ces des es fes ges' , 103 : 'aes1 bes ces des es fes ges aes' , 104 : 'bes1 ces des es fes ges aes bes' }

# intervals
IntervalsEasySimpleTransposeList = [ 'c ces' , 'c ges' , 'c des' , 'c aes' , 'c es' , 'c bes' , 'c f' , 'c c' , 'c g' , 'c d' , 'c a' , 'c e' , 'c b' , 'c fis' , 'c cis' ]
IntervalsTopNotesList = [ "c'" , "cis'" , "des'" , "d'" , "es'" , "e'" , "fes'" , "f'" , "fis'" , "ges'" , "g'" , "gis'" , "aes'" , "a'" , "bes'" , "b'" , "ces''" , "c''" , "cis''" ]
IntervalsNameList = [ 'PP' , 'AP' , 'm2' , 'M2' , 'm3' , 'M3' , 'd4' , 'P4' , 'A4' , 'd5' , 'P5' , 'A5' , 'm6' , 'M6' , 'm7' , 'M7' , 'd8' , 'P8' , 'A8' ]
IntervalsInvertedNameList = [ 'P8' , 'd8' , 'M7' , 'm7' , 'M6' , 'm6' , 'A5' , 'P5' , 'd5' , 'A4' , 'P4' , 'd4' , 'M3' , 'm3' , 'M2' , 'm2' , 'AP' , 'PP' , 'd8' ]
IntervalsHardSimpleTransposeList = [ 'c dis' , 'c eis' , 'c fes' , 'c gis' , 'c ais' , 'c bis' ]
IntervalsInScalesList = [ "<a' cis''>1" , "<b' g''>1" , "<fis' e''>1" , "<g' a'>1" , "<des' bes'>1" , "<b' ais''>1" , "<ais' cisis''>1" , "<bis' gis''>1" , "<gis' ais'>1" ]
IntervalsInScalesQuestions = [ 'Major' , 'Natural Minor' , 'Harmonic Minor' , 'Melodic Minor' ]
IntervalsInScalesKeyDict = { 'Major': [ 'D, A, E' , 'C, G, D' , 'G, D, A, E, B' , 'B \\flat, F, C, G, D' , 'C \\flat, G \\flat, D \\flat, A \\flat' , 'B, F \sharp' , 'none' , 'C \sharp' , 'B, F \sharp, C \sharp' ] , 'Natural Minor': [ 'B, F \sharp, C \sharp' , 'A, E, B' , 'E, B, F \sharp, C \sharp, G \sharp' , 'G, D, A, E, B' , 'A \\flat, E \\flat, B \\flat, F' , 'G \sharp, D \sharp' , 'none' , 'A \sharp' , 'G \sharp, D \sharp, A \sharp' ] , 'Harmonic Minor': [ 'F \sharp, C \sharp, D' , 'E, B, C' , 'E, B, C \sharp' , 'G, D, E' , 'A \\flat, B \\flat, F' , 'G \sharp, D \sharp, B' , 'D \sharp' , 'C \sharp' , 'G \sharp, D \sharp' ] , 'Melodic Minor': [ 'F \sharp, D, E' , 'E, C, D' , 'E, B, C \sharp, G, A' , 'G, D, E, B \\flat, C' , 'A \\flat, B \\flat' , 'G \sharp, B' , 'D \sharp' , 'C \sharp, D \sharp' , 'G \sharp, D \sharp, B, C \sharp' ] }

# chords
IdentifyEasyRootMajChordsList = [ "<ces es ges>1" , "<c e g>1" , "<cis eis gis>1" , "<des f aes>1" , "<d fis a>1" , "<es g bes>1" , "<e gis b>1" , "<f a c>1" , "<fis ais cis>1" , "<ges bes des>1" , "<g b d>1" , "<aes c es>1" , "<a cis e>1" , "<bes d f>1" , "<b dis fis>1" ]
IdentifyEasyRootMajChordsKeyList = [ "C \\flat \hspace #1 Maj" , "C \hspace #1 Maj" , "C \sharp \hspace #1 Maj" , "D \\flat \hspace #1 Maj" , "D \hspace #1 Maj" , "E \\flat \hspace #1 Maj" , "E \hspace #1 Maj" , "F \hspace #1 Maj" , "F \sharp \hspace #1 Maj" , "G \\flat \hspace #1 Maj" , "G \hspace #1 Maj" , "A \\flat \hspace #1 Maj" , "A \hspace #1 Maj" , "B \\flat \hspace #1 Maj" , "B \hspace #1 Maj" ]
IdentifyHardRootMajChordsList = [ "<dis fisis ais>1" , "<eis gisis bis>1" , "<fes aes ces>1" , "<gis bis dis>1" , "<ais cisis eis>1" , "<bis disis fisis>1" ]
IdentifyHardRootMajChordsKeyList = [ "D \sharp \hspace #1 Maj" , "E \sharp \hspace #1 Maj" , "F \\flat \hspace #1 Maj" , "G \sharp \hspace #1 Maj" , "A \sharp \hspace #1 Maj" , "B \sharp \hspace #1 Maj" ]
IdentifyInvMajChordsList = [ "<es ges ces>1" , "<e g c>1" , "<eis gis cis>1" , "<f aes des>1" , "<fis a d>1" , "<g bes es>1" , "<gis b e>1" , "<a c f>1" , "<ais cis fis>1" , "<bes des ges>1" , "<b d g>1" , "<c es aes>1" , "<cis e a>1" , "<d f bes>1" , "<dis fis b>1" , "<fisis ais dis>1" , "<gisis bis eis>1" , "<aes ces fes>1" , "<bis dis gis>1" , "<cisis eis ais>1" , "<disis fisis bis>1" , "<ges ces es>1" , "<g c e>1" , "<gis cis eis>1" , "<aes des f>1" , "<a d fis>1" , "<bes es g>1" , "<b e gis>1" , "<c f a>1" , "<cis fis ais>1" , "<des ges bes>1" , "<d g b>1" , "<es aes c>1" , "<e a cis>1" , "<f bes d>1" , "<fis b dis>1" , "<ais dis fisis>1" , "<bis eis gisis>1" , "<ces fes aes>1" , "<dis gis bis>1" , "<eis ais cisis>1" , "<fisis bis disis>1" ]
IdentifyInvMajChordsKeyList = [ "\column { \line { C \\flat \hspace #1 Maj } \line { 1st } }" , "\column { \line { C \hspace #1 Maj } \line { 1st } }" , "\column { \line { C \sharp \hspace #1 Maj } \line { 1st } }" , "\column { \line { D \\flat \hspace #1 Maj } \line { 1st } }" , "\column { \line { D \hspace #1 Maj } \line { 1st } }" , "\column { \line { E \\flat \hspace #1 Maj } \line { 1st } }" , "\column { \line { E \hspace #1 Maj } \line { 1st } }" , "\column { \line { F \hspace #1 Maj } \line { 1st } }" , "\column { \line { F \sharp \hspace #1 Maj } \line { 1st } }" , "\column { \line { G \\flat \hspace #1 Maj } \line { 1st } }" , "\column { \line { G \hspace #1 Maj } \line { 1st } }" , "\column { \line { A \\flat \hspace #1 Maj } \line { 1st } }" , "\column { \line { A \hspace #1 Maj } \line { 1st } }" , "\column { \line { B \\flat \hspace #1 Maj } \line { 1st } }" , "\column { \line { B \hspace #1 Maj } \line { 1st } }" , "\column { \line { D \sharp \hspace #1 Maj } \line { 1st } }" , "\column { \line { E \sharp \hspace #1 Maj } \line { 1st } }" , "\column { \line { F \\flat \hspace #1 Maj } \line { 1st } }" , "\column { \line { G \sharp \hspace #1 Maj } \line { 1st } }" , "\column { \line { A \sharp \hspace #1 Maj } \line { 1st } }" , "\column { \line { B \sharp \hspace #1 Maj } \line { 1st } }" , "\column { \line { C \\flat \hspace #1 Maj } \line { 2nd } }" , "\column { \line { C \hspace #1 Maj } \line { 2nd } }" , "\column { \line { C \sharp \hspace #1 Maj } \line { 2nd } }" , "\column { \line { D \\flat \hspace #1 Maj } \line { 2nd } }" , "\column { \line { D \hspace #1 Maj } \line { 2nd } }" , "\column { \line { E \\flat \hspace #1 Maj } \line { 2nd } }" , "\column { \line { E \hspace #1 Maj } \line { 2nd } }" , "\column { \line { F \hspace #1 Maj } \line { 2nd } }" , "\column { \line { F \sharp \hspace #1 Maj } \line { 2nd } }" , "\column { \line { G \\flat \hspace #1 Maj } \line { 2nd } }" , "\column { \line { G \hspace #1 Maj } \line { 2nd } }" , "\column { \line { A \\flat \hspace #1 Maj } \line { 2nd } }" , "\column { \line { A \hspace #1 Maj } \line { 2nd } }" , "\column { \line { B \\flat \hspace #1 Maj } \line { 2nd } }" , "\column { \line { B \hspace #1 Maj } \line { 2nd } }" , "\column { \line { D \sharp \hspace #1 Maj } \line { 2nd } }" , "\column { \line { E \sharp \hspace #1 Maj } \line { 2nd } }" , "\column { \line { F \\flat \hspace #1 Maj } \line { 2nd } }" , "\column { \line { G \sharp \hspace #1 Maj } \line { 2nd } }" , "\column { \line { A \sharp \hspace #1 Maj } \line { 2nd } }" , "\column { \line { B \sharp \hspace #1 Maj } \line { 2nd } }" ]
IdentifyEasyRootMinChordsList = [ "<ces eses ges>1" , "<c es g>1" , "<cis e gis>1" , "<des fes aes>1" , "<d f a>1" , "<es ges bes>1" , "<e g b>1" , "<f aes c>1" , "<fis a cis>1" , "<ges beses des>1" , "<g bes d>1" , "<aes ces es>1" , "<a c e>1" , "<bes des f>1" , "<b d fis>1" ]
IdentifyEasyRootMinChordsKeyList = [ "C \\flat \hspace #1 min" , "C \hspace #1 min" , "C \sharp \hspace #1 min" , "D \\flat \hspace #1 min" , "D \hspace #1 min" , "E \\flat \hspace #1 min" , "E \hspace #1 min" , "F \hspace #1 min" , "F \sharp \hspace #1 min" , "G \\flat \hspace #1 min" , "G \hspace #1 min" , "A \\flat \hspace #1 min" , "A \hspace #1 min" , "B \\flat \hspace #1 min" , "B \hspace #1 min" ]
IdentifyHardRootMinChordsList = [ "<dis fis ais>1" , "<eis gis bis>1" , "<fes aeses ces>1" , "<gis b dis>1" , "<ais cis eis>1" , "<bis dis fisis>1" ]
IdentifyHardRootMinChordsKeyList = [ "D \sharp \hspace #1 min" , "E \sharp \hspace #1 min" , "F \\flat \hspace #1 min" , "G \sharp \hspace #1 min" , "A \sharp \hspace #1 min" , "B \sharp \hspace #1 min" ]
IdentifyInvMinChordsList = [ "<eses ges ces>1" , "<es g c>1" , "<e gis cis>1" , "<fes aes des>1" , "<f a d>1" , "<ges bes es>1" , "<g b e>1" , "<aes c f>1" , "<a cis fis>1" , "<beses des ges>1" , "<bes d g>1" , "<ces es aes>1" , "<c e a>1" , "<des f bes>1" , "<d fis b>1" , "<fis ais dis>1" , "<gis bis eis>1" , "<aeses ces fes>1" , "<b dis gis>1" , "<cis eis ais>1" , "<dis fisis bis>1" , "<ges ces eses>1" , "<g c es>1" , "<gis cis e>1" , "<aes des fes>1" , "<a d f>1" , "<bes es ges>1" , "<b e g>1" , "<c f aes>1" , "<cis fis a>1" , "<des ges beses>1" , "<d g bes>1" , "<es aes ces>1" , "<e a c>1" , "<f bes des>1" , "<fis b d>1" , "<ais dis fis>1" , "<bis eis gis>1" , "<ces fes aeses>1" , "<dis gis b>1" , "<eis ais cis>1" , "<fisis bis dis>1" ]
IdentifyInvMinChordsKeyList = [ "\column { \line { C \\flat \hspace #1 min } \line { 1st } }" , "\column { \line { C \hspace #1 min } \line { 1st } }" , "\column { \line { C \sharp \hspace #1 min } \line { 1st } }" , "\column { \line { D \\flat \hspace #1 min } \line { 1st } }" , "\column { \line { D \hspace #1 min } \line { 1st } }" , "\column { \line { E \\flat \hspace #1 min } \line { 1st } }" , "\column { \line { E \hspace #1 min } \line { 1st } }" , "\column { \line { F \hspace #1 min } \line { 1st } }" , "\column { \line { F \sharp \hspace #1 min } \line { 1st } }" , "\column { \line { G \\flat \hspace #1 min } \line { 1st } }" , "\column { \line { G \hspace #1 min } \line { 1st } }" , "\column { \line { A \\flat \hspace #1 min } \line { 1st } }" , "\column { \line { A \hspace #1 min } \line { 1st } }" , "\column { \line { B \\flat \hspace #1 min } \line { 1st } }" , "\column { \line { B \hspace #1 min } \line { 1st } }" , "\column { \line { D \sharp \hspace #1 min } \line { 1st } }" , "\column { \line { E \sharp \hspace #1 min } \line { 1st } }" , "\column { \line { F \\flat \hspace #1 min } \line { 1st } }" , "\column { \line { G \sharp \hspace #1 min } \line { 1st } }" , "\column { \line { A \sharp \hspace #1 min } \line { 1st } }" , "\column { \line { B \sharp \hspace #1 min } \line { 1st } }" , "\column { \line { C \\flat \hspace #1 min } \line { 2nd } }" , "\column { \line { C \hspace #1 min } \line { 2nd } }" , "\column { \line { C \sharp \hspace #1 min } \line { 2nd } }" , "\column { \line { D \\flat \hspace #1 min } \line { 2nd } }" , "\column { \line { D \hspace #1 min } \line { 2nd } }" , "\column { \line { E \\flat \hspace #1 min } \line { 2nd } }" , "\column { \line { E \hspace #1 min } \line { 2nd } }" , "\column { \line { F \hspace #1 min } \line { 2nd } }" , "\column { \line { F \sharp \hspace #1 min } \line { 2nd } }" , "\column { \line { G \\flat \hspace #1 min } \line { 2nd } }" , "\column { \line { G \hspace #1 min } \line { 2nd } }" , "\column { \line { A \\flat \hspace #1 min } \line { 2nd } }" , "\column { \line { A \hspace #1 min } \line { 2nd } }" , "\column { \line { B \\flat \hspace #1 min } \line { 2nd } }" , "\column { \line { B \hspace #1 min } \line { 2nd } }" , "\column { \line { D \sharp \hspace #1 min } \line { 2nd } }" , "\column { \line { E \sharp \hspace #1 min } \line { 2nd } }" , "\column { \line { F \\flat \hspace #1 min } \line { 2nd } }" , "\column { \line { G \sharp \hspace #1 min } \line { 2nd } }" , "\column { \line { A \sharp \hspace #1 min } \line { 2nd } }" , "\column { \line { B \sharp \hspace #1 min } \line { 2nd } }" ]
IdentifyEasyRootDimChordsList = [ "<ces eses geses>1" , "<c es ges>1" , "<cis e g>1" , "<des fes aeses>1" , "<d f aes>1" , "<es ges beses>1" , "<e g bes>1" , "<f aes ces>1" , "<fis a c>1" , "<ges beses deses>1" , "<g bes des>1" , "<aes ces eses>1" , "<a c es>1" , "<bes des fes>1" , "<b d f>1" ]
IdentifyEasyRootDimChordsKeyList = [ "C \\flat \hspace #1 dim" , "C \hspace #1 dim" , "C \sharp \hspace #1 dim" , "D \\flat \hspace #1 dim" , "D \hspace #1 dim" , "E \\flat \hspace #1 dim" , "E \hspace #1 dim" , "F \hspace #1 dim" , "F \sharp \hspace #1 dim" , "G \\flat \hspace #1 dim" , "G \hspace #1 dim" , "A \\flat \hspace #1 dim" , "A \hspace #1 dim" , "B \\flat \hspace #1 dim" , "B \hspace #1 dim" ]
IdentifyHardRootDimChordsList = [ "<dis fis a>1" , "<eis gis b>1" , "<fes aeses ceses>1" , "<gis b d>1" , "<ais cis e>1" , "<bis dis fis>1" ]
IdentifyHardRootDimChordsKeyList = [ "D \sharp \hspace #1 dim" , "E \sharp \hspace #1 dim" , "F \\flat \hspace #1 dim" , "G \sharp \hspace #1 dim" , "A \sharp \hspace #1 dim" , "B \sharp \hspace #1 dim" ]
IdentifyInvDimChordsList = [ "<eses geses ces>1" , "<es ges c>1" , "<e g cis>1" , "<fes aeses des>1" , "<f aes d>1" , "<ges beses es>1" , "<g bes e>1" , "<aes ces f>1" , "<a c fis>1" , "<beses deses ges>1" , "<bes des g>1" , "<ces eses aes>1" , "<c ees a>1" , "<des fes bes>1" , "<d f b>1" , "<fis a dis>1" , "<gis b eis>1" , "<aeses ceses fes>1" , "<b d gis>1" , "<cis e ais>1" , "<dis fis bis>1" , "<geses ces eses>1" , "<ges c es>1" , "<g cis e>1" , "<aeses des fes>1" , "<aes d f>1" , "<beses es ges>1" , "<bes e g>1" , "<ces f aes>1" , "<c fis a>1" , "<deses ges beses>1" , "<des g bes>1" , "<eses aes ces>1" , "<es a c>1" , "<fes bes des>1" , "<f b d>1" , "<a dis fis>1" , "<b eis gis>1" , "<ceses fes aeses>1" , "<d gis b>1" , "<e ais cis>1" , "<fis bis dis>1" ]
IdentifyInvDimChordsKeyList = [ "\column { \line { C \\flat \hspace #1 dim } \line { 1st } }" , "\column { \line { C \hspace #1 dim } \line { 1st } }" , "\column { \line { C \sharp \hspace #1 dim } \line { 1st } }" , "\column { \line { D \\flat \hspace #1 dim } \line { 1st } }" , "\column { \line { D \hspace #1 dim } \line { 1st } }" , "\column { \line { E \\flat \hspace #1 dim } \line { 1st } }" , "\column { \line { E \hspace #1 dim } \line { 1st } }" , "\column { \line { F \hspace #1 dim } \line { 1st } }" , "\column { \line { F \sharp \hspace #1 dim } \line { 1st } }" , "\column { \line { G \\flat \hspace #1 dim } \line { 1st } }" , "\column { \line { G \hspace #1 dim } \line { 1st } }" , "\column { \line { A \\flat \hspace #1 dim } \line { 1st } }" , "\column { \line { A \hspace #1 dim } \line { 1st } }" , "\column { \line { B \\flat \hspace #1 dim } \line { 1st } }" , "\column { \line { B \hspace #1 dim } \line { 1st } }" , "\column { \line { D \sharp \hspace #1 dim } \line { 1st } }" , "\column { \line { E \sharp \hspace #1 dim } \line { 1st } }" , "\column { \line { F \\flat \hspace #1 dim } \line { 1st } }" , "\column { \line { G \sharp \hspace #1 dim } \line { 1st } }" , "\column { \line { A \sharp \hspace #1 dim } \line { 1st } }" , "\column { \line { B \sharp \hspace #1 dim } \line { 1st } }" , "\column { \line { C \\flat \hspace #1 dim } \line { 2nd } }" , "\column { \line { C \hspace #1 dim } \line { 2nd } }" , "\column { \line { C \sharp \hspace #1 dim } \line { 2nd } }" , "\column { \line { D \\flat \hspace #1 dim } \line { 2nd } }" , "\column { \line { D \hspace #1 dim } \line { 2nd } }" , "\column { \line { E \\flat \hspace #1 dim } \line { 2nd } }" , "\column { \line { E \hspace #1 dim } \line { 2nd } }" , "\column { \line { F \hspace #1 dim } \line { 2nd } }" , "\column { \line { F \sharp \hspace #1 dim } \line { 2nd } }" , "\column { \line { G \\flat \hspace #1 dim } \line { 2nd } }" , "\column { \line { G \hspace #1 dim } \line { 2nd } }" , "\column { \line { A \\flat \hspace #1 dim } \line { 2nd } }" , "\column { \line { A \hspace #1 dim } \line { 2nd } }" , "\column { \line { B \\flat \hspace #1 dim } \line { 2nd } }" , "\column { \line { B \hspace #1 dim } \line { 2nd } }" , "\column { \line { D \sharp \hspace #1 dim } \line { 2nd } }" , "\column { \line { E \sharp \hspace #1 dim } \line { 2nd } }" , "\column { \line { F \\flat \hspace #1 dim } \line { 2nd } }" , "\column { \line { G \sharp \hspace #1 dim } \line { 2nd } }" , "\column { \line { A \sharp \hspace #1 dim } \line { 2nd } }" , "\column { \line { B \sharp \hspace #1 dim } \line { 2nd } }" ]
IdentifyEasyRootAugChordsList = [ "<ces es g>1" , "<c e gis>1" , "<cis eis gisis>1" , "<des f a>1" , "<d fis ais>1" , "<es g b>1" , "<e gis bis>1" , "<f a cis>1" , "<fis ais cisis>1" , "<ges bes d>1" , "<g b dis>1" , "<aes c e>1" , "<a cis eis>1" , "<bes d fis>1" , "<b dis fisis>1" ]
IdentifyEasyRootAugChordsKeyList = [ "C \\flat \hspace #1 aug" , "C \hspace #1 aug" , "C \sharp \hspace #1 aug" , "D \\flat \hspace #1 aug" , "D \hspace #1 aug" , "E \\flat \hspace #1 aug" , "E \hspace #1 aug" , "F \hspace #1 aug" , "F \sharp \hspace #1 aug" , "G \\flat \hspace #1 aug" , "G \hspace #1 aug" , "A \\flat \hspace #1 aug" , "A \hspace #1 aug" , "B \\flat \hspace #1 aug" , "B \hspace #1 aug" ]
IdentifyHardRootAugChordsList = [ "<dis fisis aisis>1" , "<eis gisis bisis>1" , "<fes aes c>1" , "<gis bis disis>1" , "<ais cisis eisis>1" ]
IdentifyHardRootAugChordsKeyList = [ "D \sharp \hspace #1 aug" , "E \sharp \hspace #1 aug" , "F \\flat \hspace #1 aug" , "G \sharp \hspace #1 aug" , "A \sharp \hspace #1 aug" ]
IdentifyInvAugChordsList = [ "<es g ces>1" , "<e gis c>1" , "<eis gisis cis>1" , "<f a des>1" , "<fis ais d>1" , "<g b es>1" , "<gis bis e>1" , "<a cis f>1" , "<ais cisis fis>1" , "<bes d ges>1" , "<b dis g>1" , "<c e aes>1" , "<cis eis a>1" , "<d fis bes>1" , "<dis fisis b>1" , "<fisis aisis dis>1" , "<gisis bisis eis>1" , "<aes c fes>1" , "<bis disis gis>1" , "<cisis eisis ais>1" , "<g ces es>1" , "<gis c e>1" , "<gisis cis eis>1" , "<a des f>1" , "<ais d fis>1" , "<b es g>1" , "<bis e gis>1" , "<cis f a>1" , "<cisis fis ais>1" , "<d ges bes>1" , "<dis g b>1" , "<e aes c>1" , "<eis a cis>1" , "<fis bes d>1" , "<fisis b dis>1" , "<aisis dis fisis>1" , "<bisis eis gisis>1" , "<c fes aes>1" , "<disis gis bis>1" , "<eisis ais cisis>1" ]
IdentifyInvAugChordsKeyList = [ "\column { \line { C \\flat \hspace #1 aug } \line { 1st } }" , "\column { \line { C \hspace #1 aug } \line { 1st } }" , "\column { \line { C \sharp \hspace #1 aug } \line { 1st } }" , "\column { \line { D \\flat \hspace #1 aug } \line { 1st } }" , "\column { \line { D \hspace #1 aug } \line { 1st } }" , "\column { \line { E \\flat \hspace #1 aug } \line { 1st } }" , "\column { \line { E \hspace #1 aug } \line { 1st } }" , "\column { \line { F \hspace #1 aug } \line { 1st } }" , "\column { \line { F \sharp \hspace #1 aug } \line { 1st } }" , "\column { \line { G \\flat \hspace #1 aug } \line { 1st } }" , "\column { \line { G \hspace #1 aug } \line { 1st } }" , "\column { \line { A \\flat \hspace #1 aug } \line { 1st } }" , "\column { \line { A \hspace #1 aug } \line { 1st } }" , "\column { \line { B \\flat \hspace #1 aug } \line { 1st } }" , "\column { \line { B \hspace #1 aug } \line { 1st } }" , "\column { \line { D \sharp \hspace #1 aug } \line { 1st } }" , "\column { \line { E \sharp \hspace #1 aug } \line { 1st } }" , "\column { \line { F \\flat \hspace #1 aug } \line { 1st } }" , "\column { \line { G \sharp \hspace #1 aug } \line { 1st } }" , "\column { \line { A \sharp \hspace #1 aug } \line { 1st } }" , "\column { \line { C \\flat \hspace #1 aug } \line { 2nd } }" , "\column { \line { C \hspace #1 aug } \line { 2nd } }" , "\column { \line { C \sharp \hspace #1 aug } \line { 2nd } }" , "\column { \line { D \\flat \hspace #1 aug } \line { 2nd } }" , "\column { \line { D \hspace #1 aug } \line { 2nd } }" , "\column { \line { E \\flat \hspace #1 aug } \line { 2nd } }" , "\column { \line { E \hspace #1 aug } \line { 2nd } }" , "\column { \line { F \hspace #1 aug } \line { 2nd } }" , "\column { \line { F \sharp \hspace #1 aug } \line { 2nd } }" , "\column { \line { G \\flat \hspace #1 aug } \line { 2nd } }" , "\column { \line { G \hspace #1 aug } \line { 2nd } }" , "\column { \line { A \\flat \hspace #1 aug } \line { 2nd } }" , "\column { \line { A \hspace #1 aug } \line { 2nd } }" , "\column { \line { B \\flat \hspace #1 aug } \line { 2nd } }" , "\column { \line { B \hspace #1 aug } \line { 2nd } }" , "\column { \line { D \sharp \hspace #1 aug } \line { 2nd } }" , "\column { \line { E \sharp \hspace #1 aug } \line { 2nd } }" , "\column { \line { F \\flat \hspace #1 aug } \line { 2nd } }" , "\column { \line { G \sharp \hspace #1 aug } \line { 2nd } }" , "\column { \line { A \sharp \hspace #1 aug } \line { 2nd } }" ]
IdentifyEasyRootDomSevChordsList = [ "<c e g bes>1" , "<cis eis gis b>1" , "<des f aes ces>1" , "<d fis a c>1" , "<es g bes des>1" , "<e gis b d>1" , "<f a c es>1" , "<fis ais cis e>1" , "<ges bes des fes>1" , "<g b d f>1" , "<aes c es ges>1" , "<a cis e g>1" , "<bes d f aes>1" , "<b dis fis a>1" ]
IdentifyEasyRootDomSevChordsKeyList = [ "C7" , "C \sharp 7" , "D \\flat 7" , "D7" , "E \\flat 7" , "E7" , "F7" , "F \sharp 7" , "G \\flat 7" , "G7" , "A \\flat 7" , "A7" , "B \\flat 7" , "B7" ]
IdentifyEasyRootDomSevChordsInvKeyList = [ "C7 \hspace #1 root" , "C \sharp 7 \hspace #1 root" , "D \\flat 7 \hspace #1 root" , "D7 \hspace #1 root" , "E \\flat 7 \hspace #1 root" , "E7 \hspace #1 root" , "F7 \hspace #1 root" , "F \sharp 7 \hspace #1 root" , "G \\flat 7 \hspace #1 root" , "G7 \hspace #1 root" , "A \\flat 7 \hspace #1 root" , "A7 \hspace #1 root" , "B \\flat 7 \hspace #1 root" , "B7 \hspace #1 root" ]
IdentifyEasyRootDomSevChordsKeysKeyList = [ "(F maj/min)" , "(F \sharp maj/min)" , "(G \\flat maj/min)" , "(G maj\min)" , "(A \\flat maj/min)" , "(A maj/min)" , "(B \\flat maj/min)" , "(B maj/min)" , "(C \\flat maj/min)" , "(C maj/min)" , "(D \\flat maj/min)" , "(D maj/min)" , "(E \\flat maj/min)" , "(E maj/min)" ]
IdentifyHardRootDomSevChordsList = [ "<gis bis dis fis>1" ]
IdentifyHardRootDomSevChordsKeyList = [ "G \sharp 7" ]
IdentifyHardRootDomSevChordsInvKeyList = [ "G \sharp 7 \hspace #1 root" ]
IdentifyHardRootDomSevChordsKeysKeyList = [ "(C \sharp maj/min)" ]
IdentifyInvDomSevChordsList = [ "<e g bes c>1" , "<eis gis b cis>1" , "<f aes ces des>1" , "<fis a c d>1" , "<g bes des es>1" , "<gis b d e>1" , "<a c es f>1" , "<ais cis e fis>1" , "<bes des fes ges>1" , "<b d f g>1" , "<c es ges aes>1" , "<cis e g a>1" , "<d f aes bes>1" , "<dis fis a b>1" , "<bis dis fis gis>1" , "<g bes c e>1" , "<gis b cis eis>1" , "<aes ces des f>1" , "<a c d fis>1" , "<bes des es g>1" , "<b d e gis>1" , "<c es f a>1" , "<cis e fis ais>1" , "<des fes ges bes>1" , "<d f g b>1" , "<es ges aes c>1" , "<e g a cis>1" , "<f aes bes d>1" , "<fis a b dis>1" , "<dis fis gis bis>1" , "<bes c e g>1" , "<b cis eis gis>1" , "<ces des f aes>1" , "<c d fis a>1" , "<des es g bes>1" , "<d e gis b>1" , "<es f a c>1" , "<e fis ais cis>1" , "<fes ges bes des>1" , "<f g b d>1" , "<ges aes c es>1" , "<g a cis e>1" , "<aes bes d f>1" , "<a b dis fis>1" , "<fis gis bis dis>1" ]
IdentifyInvDomSevChordsKeyList = [ "C7 \hspace #1 1st" , "C \sharp 7 \hspace #1 1st" , "D \\flat 7 \hspace #1 1st" , "D7" , "E \\flat 7 \hspace #1 1st" , "E7 \hspace #1 1st" , "F7 \hspace #1 1st" , "F \sharp 7 \hspace #1 1st" , "G \\flat 7 \hspace #1 1st" , "G7 \hspace #1 1st" , "A \\flat 7 \hspace #1 1st" , "A7 \hspace #1 1st" , "B \\flat 7 \hspace #1 1st" , "B7 \hspace #1 1st" , "G \sharp 7 \hspace #1 1st" , "C7 \hspace #1 2nd" , "C \sharp 7 \hspace #1 2nd" , "D \\flat 7 \hspace #1 2nd" , "D7 \hspace #1 2nd" , "E \\flat 7 \hspace #1 2nd" , "E7 \hspace #1 2nd" , "F7 \hspace #1 2nd" , "F \sharp 7 \hspace #1 2nd" , "G \\flat 7 \hspace #1 2nd" , "G7 \hspace #1 2nd" , "A \\flat 7 \hspace #1 2nd" , "A7 \hspace #1 2nd" , "B \\flat 7 \hspace #1 2nd" , "B7 \hspace #1 2nd" , "G \sharp 7 \hspace #1 2nd" , "C7 \hspace #1 3rd" , "C \sharp 7 \hspace #1 3rd" , "D \\flat 7 \hspace #1 3rd" , "D7 \hspace #1 3rd" , "E \\flat 7 \hspace #1 3rd" , "E7 \hspace #1 3rd" , "F7 \hspace #1 3rd" , "F \sharp 7 \hspace #1 3rd" , "G \\flat 7 \hspace #1 3rd" , "G7 \hspace #1 3rd" , "A \\flat 7 \hspace #1 3rd" , "A7 \hspace #1 3rd" , "B \\flat 7 \hspace #1 3rd" , "B7 \hspace #1 3rd" , "G \sharp 7 \hspace #1 3rd" ]
IdentifyInvDomSevChordsKeysKeyList = [ "(F maj/min)" , "(F \sharp maj/min)" , "(G \\flat maj/min)" , "(G maj\min)" , "(A \\flat maj/min)" , "(A maj/min)" , "(B \\flat maj/min)" , "(B maj/min)" , "(C \\flat maj/min)" , "(C maj/min)" , "(D \\flat maj/min)" , "(D maj/min)" , "(E \\flat maj/min)" , "(E maj/min)" , "(C \sharp maj/min)" , "(F maj/min)" , "(F \sharp maj/min)" , "(G \\flat maj/min)" , "(G maj\min)" , "(A \\flat maj/min)" , "(A maj/min)" , "(B \\flat maj/min)" , "(B maj/min)" , "(C \\flat maj/min)" , "(C maj/min)" , "(D \\flat maj/min)" , "(D maj/min)" , "(E \\flat maj/min)" , "(E maj/min)" , "(C \sharp maj/min)" , "(F maj/min)" , "(F \sharp maj/min)" , "(G \\flat maj/min)" , "(G maj\min)" , "(A \\flat maj/min)" , "(A maj/min)" , "(B \\flat maj/min)" , "(B maj/min)" , "(C \\flat maj/min)" , "(C maj/min)" , "(D \\flat maj/min)" , "(D maj/min)" , "(E \\flat maj/min)" , "(E maj/min)" , "(C \sharp maj/min)" ]
WriteAllInvDomSevDict = { 0: [ 8 , 23 , 38 , 53 ] , 1: [ 2 , 17 , 32 , 47 ] , 2: [ 10 , 25 , 40 , 55 ] , 3: [ 4 , 19 , 34 , 49 ] , 4: [ 12 , 27 , 42 , 57 ] , 5: [ 6 , 21 , 36 , 51 ] , 6: [ 0 , 15 , 30 , 45 ] , 7: [ 9 , 24 , 39 , 54 ] , 8: [ 3 , 18 , 33 , 48 ] , 9: [ 11 , 26 , 41 , 46 ] , 10: [ 5 , 20 , 35 , 50 ] , 11: [ 13 , 28 , 43 , 58 ] , 12: [ 7 , 22 , 37 , 52 ] , 13: [ 1 , 16 , 31 , 46 ] , 14: [ 14 , 29 , 44 , 59 ] , 15: [ 4 , 19 , 34 , 49 ] , 16: [ 12 , 27 , 42 , 57 ] , 17: [ 6 , 21 , 36 , 51 ] , 18: [ 0 , 15 , 30 , 45 ] , 19: [ 9 , 24 , 39 , 54 ] , 20: [ 3 , 18 , 33 , 48 ] , 21: [ 11 , 26 , 41 , 46 ] , 22: [ 5 , 20 , 35 , 50 ] , 23: [ 13 , 28 , 43 , 58 ] , 24: [ 7 , 22 , 37 , 52 ] , 25: [ 1 , 16 , 31 , 46 ] , 26: [ 14 , 29 , 44 , 59 ] }
WriteDomSevAllInv = [ 'c' , 'd' , 'e' , 'f' , 'fis' , 'g' , 'a' , 'bes' , 'b' ]
WriteDomSevAllInvDict = { 0: [ 0 , 25 , 36 , 48 ] , 1: [ 3 , 27 , 39 , 50 ] , 2: [ 5 , 15 , 41 , 51 ] , 3: [ 6 , 17 , 42 , 54 ] , 4: [ 7 , 18 , 43 , 59 ] , 5: [ 9 , 19 , 30 , 56 ] , 6: [ 11 , 21 , 32 , 58 ] , 7: [ 12 , 23 , 34 , 45 ] , 8: [ 13 , 24 , 35 , 46 ] }
IdentifyMajSevChordsList = [ "<ces es ges bes>1" , "<c e g b>1" , "<cis eis gis bis>1" , "<des f aes c>1" , "<d fis a cis>1" , "<dis fisis ais cisis>1" , "<es g bes d>1" , "<e gis b dis>1" , "<eis gisis bis disis>1" , "<fes aes ces es>1" , "<f a c e>1" , "<fis ais cis eis>1" , "<ges bes des f>1" , "<g b d fis>1" , "<gis bis dis fisis>1" , "<aes c es g>1" , "<a cis e gis>1" , "<ais cisis eis gisis>1" , "<bes d f a>1" , "<b dis fis ais>1" , "<bis disis fisis aisis>1"  ]
IdentifyMajSevChordsKeyList = [ "C \\flat M7" , "CM7" , "C \sharp M7" , "D \\flat M7" , "DM7" , "D \sharp M7" , "E \\flat M7" , "EM7" , "E \sharp M7" , "F \\flat M7" , "FM7" , "F \sharp M7" , "G \\flat M7" , "GM7" , "G \sharp M7" , "A \\flat M7" , "AM7" , "A \sharp M7" , "B \\flat M7" , "BM7" , "B \sharp M7"  ]
IdentifyMinSevChordsList = [ "<ces e ges beses>1" , "<c es g bes>1" , "<cis e gis b>1" , "<des fes aes ces>1" , "<d f a c>1" , "<dis fis ais cis>1" , "<es ges bes des>1" , "<e g b d>1" , "<eis gis bis dis>1" , "<fes aeses ces eses>1" , "<f aes c ees>1" , "<fis a cis e>1" , "<ges beses des fes>1" , "<g bes d f>1" , "<gis b dis fis>1" , "<aes ces es ges>1" , "<a c e g>1" , "<ais cis eis gis>1" , "<bes des f aes>1" , "<b d fis a>1" , "<bis dis fisis ais>1" ]
IdentifyMinSevChordsKeyList = [ "C \\flat m7" , "Cm7" , "C \sharp m7" , "D \\flat m7" , "Dm7" , "D \sharp m7" , "E \\flat m7" , "Em7" , "E \sharp m7" , "F \\flat m7" , "Fm7" , "F \sharp m7" , "G \\flat m7" , "Gm7" , "G \sharp m7" , "A \\flat m7" , "Am7" , "A \sharp m7" , "B \\flat m7" , "Bm7" , "B \sharp m7" ]
IdentifyHalfDimChordsList = [ "<ces e geses beses>1" , "<c es ges bes>1" , "<cis e g b>1" , "<des fes aeses ces>1" , "<d f aes c>1" , "<dis fis a cis>1" , "<es ges beses des>1" , "<e g bes d>1" , "<eis gis b dis>1" , "<fes aeses ceses eses>1" , "<f aes ces ees>1" , "<fis a c e>1" , "<ges beses deses fes>1" , "<g bes des f>1" , "<gis b d fis>1" , "<aes ces eses ges>1" , "<a c es g>1" , "<ais cis e gis>1" , "<bes des fes aes>1" , "<b d f a>1" , "<bis dis fis ais>1" ]
IdentifyHalfDimChordsKeyList = [ "C \\flat ø7" , "Cø7" , "C \sharp ø7" , "D \\flat ø7" , "Dø7" , "D \sharp ø7" , "E \\flat ø7" , "Eø7" , "E \sharp ø7" , "F \\flat ø7" , "Fø7" , "F \sharp ø7" , "G \\flat ø7" , "Gø7" , "G \sharp ø7" , "A \\flat ø7" , "Aø7" , "A \sharp ø7" , "B \\flat ø7" , "Bø7" , "B \sharp ø7" ]
IdentifyFullDimChordsList = [ "<c es ges beses>1" , "<cis e g bes>1" , "<des fes aeses ceses>1" , "<d f aes ces>1" , "<dis fis a c>1" , "<es ges beses deses>1" , "<e g bes des>1" , "<eis gis b d>1" , "<f aes ces eses>1" , "<fis a c es>1" , "<ges beses deses feses>1" , "<g bes des fes>1" , "<gis b d f>1" , "<aes ces eses geses>1" , "<a c es ges>1" , "<ais cis e g>1" , "<bes des fes aeses>1" , "<b d f aes>1" , "<bis dis fis a>1" ]
IdentifyFullDimChordsKeyList = [ "Co7" , "C \sharp o7" , "D \\flat o7" , "Do7" , "D \sharp o7" , "E \\flat o7" , "Eo7" , "E \sharp o7" , "Fo7" , "F \sharp o7" , "G \\flat o7" , "Go7" , "G \sharp o7" , "A \\flat o7" , "Ao7" , "A \sharp o7" , "B \\flat o7" , "Bo7" , "B \sharp o7" ]
IdentifyOtherChordsTreble = [ "<e' a'>1" , "<e' a'>1" , "<e' ais'>1" , "<eis' ais'>1" , "<eis' ais'>1" , "<e' a'>1" , "<es' a'>1" , "<es' aes'>1" , "<es' aes'>1" , "<f' b'>1" , "<fis' b'>1" , "<fis' b'>1" , "<fis' b'>1" , "<fis' bis'>1" , "<f' bes'>1" , "<f' bes'>1" , "<f' bes'>1" , "<fes' bes'>1" , "<d' g'>1" , "<d' gis'>1" , "<dis' gis'>1" , "<dis' gis'>1" , "<dis' gis'>1" , "<d' g'>1" , "<d' g'>1" , "<des' g'>1" , "<des' ges'>1" , "<c' f'>1" , "<c' fis'>1" , "<cis' fis'>1" , "<cis' fis'>1" , "<cis' fis'>1" , "<c' f'>1" , "<c' f'>1" , "<ces' f'>1" , "<ces' fes'>1" , "<c'' e'' g''>1" , "<c'' e'' g''>1" , "<c'' e'' g''>1" , "<c'' es'' g''>1" , "<c'' es'' g''>1" , "<c'' e'' gis''>1" , "<c'' e'' gis''>1" , "<c'' es'' ges''>1" , "<c'' es'' ges''>1" , "<a' c'' e''>1" , "<a' c'' es''>1" , "<a' cis'' e''>1" , "<a' c'' es''>1" , "<a' cis'' e''>1" , "<a' c'' es''>1" , "<a' cis'' e''>1" , "<a' c'' es''>1" , "<a' cis'' e''>1" , "<f' a' c''>1" , "<f' a' c''>1" , "<f' a' c''>1" , "<f' aes' c''>1" , "<f' aes' c''>1" , "<f' a' cis''>1" , "<f' a' cis''>1" , "<f' aes' ces''>1" , "<f' aes' ces''>1" , "<g' b' d''>1" , "<g' bes' d''>1" , "<g' b' dis''>1" , "<g' bes' d''>1" , "<g' b' dis''>1" , "<g' bes' d''>1" , "<g' b' dis''>1" , "<g' bes' d''>1" , "<g' b' dis''>1" , "<g' a' b' c'' d'' e''>1" , "<f' g' a' b' c'' d''>1" , "<e' f' g' a' b' c''>1" , "<d' e' f' g' a' b'>1" , "<c' d' e' f' g' a'>1" , "<d' e' f' g'>1" , "<d' e' f'>1" , "<d' e'>1" , "<c' d'>1" , "s1" , "s1" , "s1" , "s1" , "s1" , "<gis' ais' bis' cis'' dis'' eis''>1" , "<fis' gis' ais' bis' cis'' dis''>1" , "<eis' fis' gis' ais' bis' cis''>1" , "<dis' eis' fis' gis' ais' bis'>1" , "<cis' dis' eis' fis' gis' ais'>1" , "<dis' eis' fis' gis'>1" , "<dis' eis' fis'>1" , "<dis' eis'>1" , "<cis' dis'>1" , "s1" , "s1" , "s1" , "s1" , "s1" , "<ges' aes' bes' ces'' des'' ees''>1" , "<fes' ges' aes' bes' ces'' des''>1" , "<ees' fes' ges' aes' bes' ces''>1" , "<des' ees' fes' ges' aes' bes'>1" , "<ces' des' ees' fes' ges' aes'>1" , "<des' ees' fes' ges'>1" , "<des' ees' fes'>1" , "<des' ees'>1" ]
IdentifyOtherChordsBass = [ "<f b>1" , "<fis b>1" , "<fis b>1" , "<fis b>1" , "<fis bis>1" , "<f bes>1" , "<f bes>1" , "<f bes>1" , "<fes bes>1" , "<g c'>1" , "<g c'>1" , "<g cis'>1" , "<gis cis'>1" , "<gis cis'>1" , "<g c'>1" , "<ges c'>1" , "<ges ces'>1" , "<ges ces'>1" , "<e a>1" , "<e a>1" , "<e a>1" , "<e ais>1" , "<eis ais>1" , "<es a>1" , "<es aes>1" , "<es aes>1" , "<es aes>1" , "<d g>1" , "<d g>1" , "<d g>1" , "<d gis>1" , "<dis gis>1" , "<des g>1" , "<des ges>1" , "<des ges>1" , "<des ges>1" , "<f a c'>1" , "<f aes c'>1" , "<f a cis'>1" , "<f aes c'>1" , "<f a cis'>1" , "<f aes c'>1" , "<f a cis'>1" , "<f aes c'>1" , "<f a cis'>1" , "<e g b>1" , "<e g b>1" , "<e g b>1" , "<e gis b>1" , "<e gis b>1" , "<e gis bis>1" , "<e gis bis>1" , "<e g bes>1" , "<e g bes>1" , "<d f a>1" , "<d fis a>1" , "<d f aes>1" , "<d fis a>1" , "<d f aes>1" , "<d fis a>1" , "<d f aes>1" , "<d fis a>1" , "<d f aes>1" , "<b, d f>1" , "<b, d f>1" , "<b, d f>1" , "<b, d fis>1" , "<b, d fis>1" , "<b, dis fis>1" , "<b, dis fis>1" , "<b, dis fisis>1" , "<b, dis fisis>1" , "s1" , "s1" , "s1" , "s1" , "s1" , "<b c'>1" , "<a b c'>1" , "<g a b c'>1" , "<f g a b>1" , "<e f g a b c'>1" , "<d e f g a b>1" , "<c d e f g a>1" , "<b, c d e f g>1" , "<a, b, c d e f>1" , "s1" , "s1" , "s1" , "s1" , "s1" , "<bis cis'>1" , "<ais bis cis'>1" , "<gis ais bis cis'>1" , "<fis gis ais bis>1" , "<eis fis gis ais bis cis'>1" , "<dis eis fis gis ais bis>1" , "<cis dis eis fis gis ais>1" , "<bis, cis dis eis fis gis>1" , "<ais, bis, cis dis eis fis>1" , "s1" , "s1" , "s1" , "s1" , "s1" , "<bes ces'>1" , "<aes bes ces'>1" , "<ges aes bes ces'>1" ]
IdentifyOtherChordsKey = [ "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Quartal" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Polychord" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" , "Cluster" ]
ChordsInScalesMaj = [ "C \\flat, G \\flat" , "F, C, G" , "F \sharp, C \sharp" , "A \\flat, D \\flat, G \\flat" , "G, D, A" , "A \\flat, E \\flat, B \\flat" , "A, E, B" , "B \\flat, F, C" , "B, F \sharp, C \sharp" , "C \\flat, G \\flat, D \\flat" , "C, G, D" , "D \\flat, A \\flat, E \\flat" , "D, A, E" , "E \\flat, B \\flat, F" , "E, B, F \sharp" , "none" , "none" , "C \\flat" , "C \sharp" , "none" , "none" , "none" , "A \\flat, E \\flat, B \\flat" , "A, E, B" , "C \\flat" , "B \\flat, F, C" , "C \\flat, G \\flat, D \\flat" , "C, G, D" , "D \\flat, A \\flat, E \\flat" , "D, A, E" , "none" , "E \\flat, B \\flat, F" , "C \\flat, G \\flat" , "F, C, G" , "G \\flat, D \\flat, A \\flat" , "G, D, A" , "B, F \sharp, C \sharp" , "C \sharp" , "none" , "E, B, F \sharp" , "F \sharp, C \sharp" , "none" , "none" , "D \\flat" , "D" , "none" , "E \\flat" , "none" , "F" , "G \\flat" , "G" , "none" , "A \\flat" , "none" , "B \\flat" , "C \\flat" , "C" , "E" , "F \sharp" , "none" , "A" , "B" , "C \sharp" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "" ]
ChordsInScalesMin = [ "A \\flat, E \\flat" , "D, A, E" , "D \sharp, A \sharp" , "F, B \\flat, E \\flat" , "E, B, F \sharp" , "F, C, G" , "F \sharp, C \sharp, G \sharp" , "G, D, A" , "G \sharp, D \sharp, A \sharp" , "A \\flat, E \\flat, B \\flat" , "A, E, B" , "B \\flat, F, C" , "B, F \sharp, C \sharp" , "C, G, D" , "C \sharp, G \sharp, D \sharp" , "none" , "none" , "A \\flat" , "A \sharp" , "none" , "none" , "none" , "F, C, G" , "F \sharp, C \sharp, G \sharp" , "A \\flat" , "G, D, A" , "A \\flat, E \\flat, B \\flat" , "A, E, B" , "B \\flat, F, C" , "B, F \sharp, C \sharp" , "none" , "C, G, D" , "A \\flat, E \\flat" , "D, A, E" , "E \\flat, B \\flat, F" , "E, B, F \sharp" , "G \sharp, D \sharp, A \sharp" , "A \sharp" , "none" , "C \sharp, G \sharp, D \sharp" , "D \sharp, A \sharp" , "none" , "none" , "B \\flat" , "B" , "none" , "C" , "none" , "D" , "E \\flat" , "E" , "none" , "F" , "none" , "G" , "A \\flat" , "A" , "C \sharp" , "D \sharp" , "none" , "F \sharp" , "G \sharp" , "A \sharp" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "none" , "" ]
ChordsInScalesHar = [ "E \\flat" , "F, E" , "F \sharp" , "F" , "G, F \sharp" , "A \\flat, G" , "A, G \sharp" , "B \\flat, A" , "B, A \sharp" , "B \\flat" , "C, B" , "C" , "D, C \sharp" , "E \\flat, D" , "E, D \sharp" , "G \sharp" , "A \sharp" , "A \\flat" , "C \sharp" , "D \sharp" , "none" , "none" , "C, G" , "C \sharp, G \sharp" , "A \\flat" , "D, A" , "E \\flat, B \\flat" , "E, B" , "F, C" , "F \sharp, C \sharp" , "none" , "G, D" , "A \\flat, E \\flat" , "A, E" , "B \\flat, F" , "B, F \sharp" , "D \sharp, A \sharp" , "none" , "none" , "G \sharp, D \sharp" , "A \sharp" , "none" , "none" , "B \\flat" , "D, B" , "none" , "E \\flat, C" , "none" , "F, D" , "E \\flat" , "G, E" , "none" , "A \\flat, F" , "none" , "B \\flat, G" , "A \\flat" , "C, A" , "E, C \sharp" , "F \sharp, D \sharp" , "none" , "A, F \sharp" , "B, G \sharp" , "C \sharp, A \sharp" , "A \\flat" , "A" , "A \sharp" , "B \\flat" , "B" , "C" , "C \sharp" , "D" , "D \sharp" , "E \\flat" , "E" , "F" , "F \sharp" , "G" , "G \sharp" , "none" , "none" , "none" , "none" , "none" , "" ]
ChordsInScalesMel = [ "none" , "G, F" , "F \sharp, G \sharp" , "A \\flat" , "G, A" , "A \\flat, B \\flat" , "A, B" , "B \\flat, C" , "B, C \sharp" , "none" , "C, D" , "E \\flat" , "D, E" , "E \\flat, F" , "E, F \sharp" , "G \sharp, A \sharp" , "A \sharp" , "none" , "C \sharp, D \sharp" , "D \sharp" , "none" , "none" , "B \\flat, C" , "B, C \sharp" , "none" , "C, D" , "E \\flat" , "D, E" , "E \\flat, F" , "E, F \sharp " , "none" , "F, G" , "A \\flat" , "G, A" , "A \\flat, B \\flat" , "A, B" , "C \sharp, D \sharp" , "D \sharp" , "none" , "F \sharp, G \sharp" , "G \sharp, A \sharp" , "A \sharp" , "none" , "E \\flat" , "D, E" , "none" , "E \\flat, F" , "none" , "F, G" , "A \\flat" , "G, A" , "none" , "A \\flat, B \\flat" , "none" , "B \\flat, C" , "none" , "C, D" , "E, F \sharp" , "F \sharp, G \sharp" , "none" , "A, B" , "B, C \sharp" , "C \sharp, D \sharp" , "A \\flat" , "A" , "A \sharp" , "B \\flat" , "B" , "C" , "C \sharp" , "D" , "D \sharp" , "E \\flat" , "E" , "F" , "F \sharp" , "G" , "G \sharp" , "none" , "none" , "none" , "none" , "none" , "" ]

# cadences - these first 3 lists MUST be the same length
IdentifyCadencesTrebleFirst = [ "\key c \major <e' g' c''>2" , "\key c \major <g' c'' e''>2" , "\key c \major <e' g' c''>2" , "\key c \major <e' g' c''>2" , "\key c \major <e' g' c''>2" , "\key c \minor <es' g' c''>2" , "\key c \minor <g' c'' es''>2" , "\key c \minor <es' g' c''>2" , "\key c \minor <es' g' c''>2" ]
IdentifyCadencesTrebleRest = [ "<d' g' b'> <e' g' c''>1" , "<g' b' d''> <g' c'' e''>1" , "<f' a' c''> <e' g' c''>1" , "<f' a' c''> <d' g' b'>1" , "<d' g' b'> <c' e' a'>1" , "<d' g' b'> <es' g' c''>1" , "<g' b' d''> <g' c'' es''>1" , "<f' aes' c''> <es' g' c''>1" , "<f' aes' c''> <d' g' b'>1" ]
IdentifyCadencesTrebleKey = [ "Perfect Authentic" , "Imperfect Authentic" , "Plagal" , "Half" , "Deceptive" , "Perfect Authentic" , "Imperfect Authentic" , "Plagal" , "Half" ]
IdentifyCadencesBass = [ "\key c \major c2 g \\noBreak c1" , "\key c \major c2 g \\noBreak c1" , "\key c \major c2 f \\noBreak c1" , "\key c \major c2 f \\noBreak g1" , "\key c \major c2 g \\noBreak a1" , "\key c \minor c2 g \\noBreak c1" , "\key c \minor c2 g \\noBreak c1" , "\key c \minor c2 f \\noBreak c1" , "\key c \minor c2 f \\noBreak g1" ]
IdentifyCadencesBassKey = [ '\key c \major c2_\markup { \with-color #red { I }} g_\markup { \with-color #red { V }} \\noBreak c1_\markup { \with-color #red { I }}' , '\key c \major c2_\markup { \with-color #red { I }} g_\markup { \with-color #red { V }} \\noBreak c1_\markup { \with-color #red { I }}' , '\key c \major c2_\markup { \with-color #red { I }} f_\markup { \with-color #red { IV }} \\noBreak c1_\markup { \with-color #red { I }}' , '\key c \major c2_\markup { \with-color #red { I }} f_\markup { \with-color #red { IV }} \\noBreak g1_\markup { \with-color #red { V }}' , '\key c \major c2_\markup { \with-color #red { I }} g_\markup { \with-color #red { V }} \\noBreak a1_\markup { \with-color #red { vi }}' , '\key c \minor c2_\markup { \with-color #red { i }} g_\markup { \with-color #red { V }} \\noBreak c1_\markup { \with-color #red { i }}' , '\key c \minor c2_\markup { \with-color #red { i }} g_\markup { \with-color #red { V }} \\noBreak c1_\markup { \with-color #red { i }}' , '\key c \minor c2_\markup { \with-color #red { i }} f_\markup { \with-color #red { iv }} \\noBreak c1_\markup { \with-color #red { i }}' , '\key c \minor c2_\markup { \with-color #red { i }} f_\markup { \with-color #red { iv }} \\noBreak g1_\markup { \with-color #red { V }}' ]
IdentifyCadencesTranspositions = [ "c aes," , "c es" , "c bes," , "c f" , "c g," , "c d" , "c e" , "c b," , "c fis" , "c cis" ]
IdentifyCadencesTranspositionsKey = [ "A \\flat" , "E \\flat" , "B \\flat" , "F" , "G" , "D" , "E" , "B" , "F \sharp" , "C \sharp" ]
WriteCadencesList = [ 'Perf. Auth.' , 'Imp. Auth.' , 'Half' , 'Plagal' , 'Dec.' ]

# transposing
TranspositionExamplesList = [
  " " , 
  "\\time 2/4 d8 fis d4  e8 cis a4  d r8 e  d cis d4  d fis8 d  e cis a4  d r8 e  d cis d4  \\bar \"|.\" " , 
  " \\time 3/2  a2 b! cis  d1 a2  bes a g  a1 a2  g e f4 g  a1 g4 f  e2 d cis  d1.  \\bar \"|.\" " ,
  " \key bes \major \\time 3/4  d8.(\\f^\markup { Allegretto } ees16 d ees f8) c-. f-.  bes,8.( c16 bes c d8) a-. d-.  g,8.( a16 g a bes8) f-. d'-.  bes4.( a8 bes4)^\markup { Purcell }  \\bar \":|\" " ,
  " \key e \minor \\time 2/2  \partial 4  e8 fis  g fis e fis g a b c  b4 e, e e'  dis e fis g  fis8 e dis cis b4^\markup { Rameau }  \\bar \"|.\" " ,
  " \key fis \minor \\time 6/8  \partial 8  fis8( | a4 fis8 cis'4 fis,8 | fis'8. e16 d8 cis4 cis8 | b4 cis8 a4 b8 | gis4.~ gis4)  \\bar \":\" " ,
  "\override TextScript #'staff-padding = #3 \key c \major \\time 3/4 \partial 8 g8^\"Morgengruss\" | g4. e'8 d c | g8. b32 a g4 r8 g | g4. e'8 f16 e d c | a8. cis16 d4. f8 | f4. b,8 \\acciaccatura d8 \\times 2/3 { c8[ b c] } | e4 d r8^\markup { \\right-align \"Schubert\" } \\bar \"||\" " ,
  " \override TextScript #'staff-padding = #3 \key f \major \\time 4/4 \partial 4 c8.(\\f c16)-. \mark \default f2 c4-. a-. f-. r r8 c'8(-2\p a'_\markup { dolce } g) g8( f) f f f(\< g16 f e8 f)\! fis4(\> g)\! r8 c,( bes'^\markup { Beethoven } a) \\bar \":\" " ,
  " \key gis \minor dis8 b' ais gis dis b' ais gis dis4 eis8 fisis gis4 r dis' dis dis b cis8 dis e4 dis2 dis8 b ais gis dis' b ais gis dis4 eis8 fisis gis4 r \\bar \"|.\" " ,
  " \key c \minor c2.\\f c4 c2 c4 es d2 d r4 d es c b2. b4 c2\\fermata \\bar \":\" " ,
  " \key c \major r2 r4 g4 | c4. e8 d c b c | d4. b8 g4 g | d'4. f8 e d c d | d4( e) r c8 e \\bar \"|.\" " ,
  " \key g \major \\time 6/8 \partial 8 d8^\"Presto\"( | d g b d d d | d c b a) r c( | b g d c a e' | g4. fis8) r d( | d g b d d d | d c b a) r c( | c b g b a fis | a4. g8) r^\markup { \\right-align { Haydn } } \\bar \"|.\" " ,
  ]
TranspositionExamplesKeysList = [ '' , 'D Major' , 'D Minor' , 'B \\flat Major' , 'E Minor' , 'F \sharp Minor' , 'C Major' , 'F Major' , 'G \sharp Minor' , 'C Minor' , 'C Major' , 'G Major' ]
TranspositionIntervalsList = [ '↑m2' , '↑M2' , '↑m3' , '↑M3' , '↑P4' , '↑P5' , '↑m6' , '↑M6' , '↑m7' , '↑M7' , '↓m2' , '↓M2' , '↓m3' , '↓M3' , '↓P4' , '↓P5' , '↓m6' , '↓M6' , '↓m7' , '↓M7' ]
TranspositionIntervalsListKey = [ 'c des' , 'c d' , 'c es' , 'c e' , 'c f' , 'c g' , 'c aes' , 'c a' , 'c bes' , 'c b' , 'c b,' , 'c bes,' , 'c a,' , 'c aes,' , 'c g,' , 'c f,' , 'c e,' , 'c es,' , 'c d,' , 'c des,' ]
TranspositionExamplesNewKeysDict = { 0: [ ] , 1: [ 'E \\flat Major' , 'E Major' , 'F Major' , 'F \sharp Major' , 'G Major' , 'A Major' , 'B \\flat Major' , 'B Major' , 'C Major' , 'C \sharp Major' , 'C \sharp Major' , 'C Major' , 'B Major' , 'B \\flat Major' , 'A Major' , 'G Major' , 'F \sharp Major' , 'F Major' , 'E Major' , 'E \\flat Major' ] , 2: [ 'E \\flat Minor' , 'E Minor' , 'F Minor' , 'F \sharp Minor' , 'G Minor' , 'A Minor' , 'B \\flat Minor' , 'Minoror' , 'C Minor' , 'C \sharp Minor' , 'C \sharp Minor' , 'C Minor' , 'B Minor' , 'B \\flat Minor' , 'A Minor' , 'G Minor' , 'F \sharp Minor' , 'F Minor' , 'E Minor' , 'E \\flat Minor' ] , 3: [ 'C \\flat Major' , 'C Major' , 'D \\flat Major' , 'D Major' , 'E \\flat Major' , 'F Major' , 'G \\flat Major' , 'G Major' , 'A \\flat Major' , 'A Major' , 'A Major' , 'A \\flat' , 'G Major' , 'G \\flat Major' , 'F Major' , 'E \\flat Major' , 'D Major' , 'D \\flat Major' , 'C Major' , 'C \\flat Major' ] , 4: [ 'F Minor' , 'F \sharp Minor' , 'G Minor' , 'G \sharp Minor' , 'A Minor' , 'B Minor' , 'C Minor' , 'C \sharp Minor' , 'D Minor' , 'D \sharp Minor' , 'D \sharp Minor' , 'D Minor' , 'C \sharp Minor' , 'C Minor' , 'B Minor' , 'A Minor' , 'G \sharp Minor' , 'G Minor' , 'F \sharp Minor' , 'F Minor' ]  , 5: [ 'G Minor' , 'G \sharp Minor' , 'A Minor' , 'A \sharp Minor' , 'B Minor' , 'C \sharp Minor' , 'D Minor' , 'D \sharp Minor' , 'E Minor' , 'E \sharp Minor' , 'E \sharp Minor' , 'E Minor' , 'D \sharp Minor' , 'D Minor' , 'C \sharp Minor' , 'B Minor' , 'A \sharp Minor' , 'A Minor' , 'G \sharp Minor' , 'G Minor' ] , 6: [ 'D \\flat Major' , 'D Major' , 'E \\flat Major' , 'E Major' , 'F Major' , 'G Major' , 'A \\flat Major' , 'A Major' , 'B \\flat Major' , 'B Major' , 'B Major' , 'B \\flat Major' , 'A Major' , 'A \\flat Major' , 'G Major' , 'F Major' , 'E Major' , 'E \\flat Major' , 'D Major' , 'D \\flat Major' ]  , 7: [ 'G \\flat Major' , 'G Major' , 'A \\flat Major' , 'A Major' , 'B \\flat Major' , 'C Major' , 'D \\flat Major' , 'D Major' , 'E \\flat Major' , 'E Major' , 'E Major' , 'E \\flat Major' , 'D Major' , 'D \\flat Major' , 'C Major' , 'B \\flat Major' , 'A Major' , 'A \\flat Major' , 'G Major' , 'G \\flat Major' ]  , 8: [ 'A Minor' , 'A \sharp Minor' , 'B Minor' , 'B \sharp Minor' , 'C \sharp Minor' , 'D \sharp Minor' , 'E Minor' , 'E \sharp Minor' , 'F \sharp Minor' , 'F \doublesharp Minor' , 'F \doublesharp Minor' , 'F \sharp Minor' , 'E \sharp Minor' , 'E Minor' , 'D \sharp Minor' , 'C \sharp Minor' , 'B \sharp Minor' , 'B Minor' , 'A \sharp Minor' , 'A Minor' ]  , 9: [ 'D \\flat Minor' , 'D Minor' , 'E \\flat Minor' , 'E Minor' , 'F Minor' , 'G Minor' , 'A \\flat Minor' , 'A Minor' , 'B \\flat Minor' , 'B Minor' , 'B Minor' , 'B \\flat Minor' , 'A Minor' , 'A \\flat Minor' , 'G Minor' , 'F Minor' , 'E Minor' , 'E \\flat Minor' , 'D Minor' , 'D \\flat Minor' ] , 10: [ 'D \\flat Major' , 'D Major' , 'E \\flat Major' , 'E Major' , 'F Major' , 'G Major' , 'A \\flat Major' , 'A Major' , 'B \\flat Major' , 'B Major' , 'B Major' , 'B \\flat Major' , 'A Major' , 'A \\flat Major' , 'G Major' , 'F Major' , 'E Major' , 'E \\flat Major' , 'D Major' , 'D \\flat Major' ]  , 11: [ 'A \\flat Major' , 'A Major' , 'B \\flat Major' , 'B Major' , 'C Major' , 'D Major' , 'E \\flat Major' , 'E Major' , 'F Major' , 'F \sharp Major' , 'F \sharp Major' , 'F Major' , 'E Major' , 'E \\flat Major' , 'D Major' , 'C Major' , 'B Major' , 'B \\flat Major' , 'A Major' , 'A \\flat Major' ] }

# time signatures
TimeSigList = [
  " " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Add the missing barlines: }} { \override Clef  #'transparent = ##t \\time 4/4  \cadenzaOn a'8 a'16 a' a'8 a' a'4 a'8 a'~ a'2 a'4 a'16 a' a'8 a'4 a'16 a' a'8 a'4. a'8 a'1 \cadenzaOff \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Add the missing barlines: }} { \override Clef  #'transparent = ##t \\time 6/4  \cadenzaOn a'2 a'4 a' a' a' a'8 a' a'4 a' a'2. a'4 a'2 a'4 a'2 a'4 a'8 a' a' a' a'4 a'2 \cadenzaOff \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Add the missing barlines: }} \\relative c''{ \override Clef  #'transparent = ##t \\time 7/8  \cadenzaOn a4. a8[ a] a4 a8[ a] a4. a8[ a] a8[ a a a] a4 a8 a4 a8[ a] a4. \cadenzaOff \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Add the missing barlines: }} \\relative c''{ \override Clef  #'transparent = ##t \\time 5/8  \cadenzaOn a4 a8 a4 a8[ a16 a a a] a[ a a a] a[ a a a a a] a4 a8[ a16 a16 a8] a8.[ a16] \cadenzaOff \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Add the correct time signature: }} { \\notimesig \\time 9/8 \partial 8 a'8 a' a' a' a'16 a' a' a' a'8 a' a' a'16 a' a'8 a'4 a'4. a'8 a' a' a' a' a'~ a' a'4 a'8 a' a' a'4. a'4. a'8 a' a'16 a' \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Add the correct time signature: }} { \\notimesig \\time 3/4 a'4 a'8 a' a'4 a'2. a'2 a'4~ a'2. a'4. a'8 a'4 a'2. \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Add the correct time signature: }} \\relative c''{ \\notimesig \\time 5/16 s8 s s16 \\bar \"\" a16[ a8] a8 a16[ a32 a a a] a16.[ a32] a16[ a] a8 a16 a8 a16[ a a] \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Add the correct time signature: }} \\relative c''{ \\notimesig \\time 7/8 s4 s s s8 \\bar \"\" a8[ a] a4 a4. a8[ a16 a a a] a8[ a16 a] a4 a a a4. a4 a8 a8[ a16 a] a8[ a] \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Complete the following measures with rests: }} { a'8 a'4 s8 a'2 a'4 s4 s a'4  a'2 s2  s4 a'2.  } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Complete the following measures with rests: }} { \\time 6/8 a'8 s8 s a'4 s8 s4. s4. a'4 s8 s s s16 a'16 a'16 a' s8 s s a'8 a' } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Complete the following measures with rests: }} \\relative c''{ \\time 7/4 \hideNotes \override TextScript #'padding = #4.0 \[ a2^\"2+2+3\" a4 \] \\unHideNotes a8[ a] a2. a8[ a a] \hideNotes \[ a a4 a8 a8 \] \\unHideNotes a4 a8[ a a a] a4 a a \hideNotes \[ a2 a \] \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Complete the following measures with rests: }} \\relative c''{ \\time 10/8 \override TextScript #'padding = #4.0 a8.[^\"3+2+2+3\" a16 a8] a4 \hideNotes \[ a8 a a \] \\unHideNotes a4 a4 a8 \hideNotes \[ a8 a a \] \\unHideNotes a8 a a4 a8[ a a] a \hideNotes \[ a8 a \] \\unHideNotes a8 a a4 \\bar \"||\" } " ,
  ]
TimeSigKeyList = [
  " " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Add the missing barlines: }} { \override Staff.BarLine #\'color = #red \override Clef  #'transparent = ##t \\time 4/4  \\autoBeamOff a'8 a'16 a' a'8 a' a'4 a'8 a'~ a'2 a'4 a'16 a' a'8 a'4 a'16 a' a'8 a'4. a'8 a'1 \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Add the missing barlines: }} { \override Staff.BarLine #\'color = #red \override Clef  #'transparent = ##t \\time 6/4  \\autoBeamOff a'2 a'4 a' a' a' a'8 a' a'4 a' a'2. a'4 a'2 a'4 a'2 a'4 a'8 a' a' a' a'4 a'2 \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Add the missing barlines: }} \\relative c''{ \override Staff.BarLine #\'color = #red \override Clef  #'transparent = ##t \\time 7/8  \\autoBeamOff a4. a8[ a] a4 a8[ a] a4. a8[ a] a8[ a a a] a4 a8 a4 a8[ a] a4. \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Add the missing barlines: }} \\relative c''{ \override Staff.BarLine #\'color = #red \override Clef  #'transparent = ##t \\time 5/8  \\autoBeamOff a4 a8 a4 a8[ a16 a a a] a[ a a a] a[ a a a a a] a4 a8[ a16 a16 a8] a8.[ a16] \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Add the correct time signature: }} { \override Staff.TimeSignature #\'color = #red \\time 9/8 \partial 8 a'8 a' a' a' a'16 a' a' a' a'8 a' a' a'16 a' a'8 a'4 a'4. a'8 a' a' a' a' a'~ a' a'4 a'8 a' a' a'4. a'4. a'8 a' a'16 a' \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Add the correct time signature: }} { \override Staff.TimeSignature #\'color = #red \\time 3/4 a'4 a'8 a' a'4 a'2. a'2 a'4~ a'2. a'4. a'8 a'4 a'2. \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Add the correct time signature: }} \\relative c''{ \override Staff.TimeSignature #\'color = #red \\time 5/16 s8 s s16 \\bar \"\" a16[ a8] a8 a16[ a32 a a a] a16.[ a32] a16[ a] a8 a16 a8 a16[ a a] \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Add the correct time signature: }} \\relative c''{ \override Staff.TimeSignature #\'color = #red \\time 7/8 s4 s s s8 \\bar \"\" a8[ a] a4 a4. a8[ a16 a a a] a8[ a16 a] a4 a a a4. a4 a8 a8[ a16 a] a8[ a] \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Complete the following measures with rests: }} { \override Rest #\'color = #red a'8 a'4 r8 a'2 a'4 r4 r a'4  a'2 r2  r4 a'2.  } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Complete the following measures with rests: }} { \override Rest #\'color = #red \\time 6/8 a'8 r8 r a'4 r8 r2. a'4 r8 r r8. a'16 a'16 a' r8 r r a'8 a' } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Complete the following measures with rests: }} \\relative c''{ \override Rest #\'color = #red \\time 7/4 \override TextScript #'padding = #4.0 \[ r2^\"2+2+3\" r4 \] a8[ a] a2. a8[ a a] \[ r r2 \] a4 a8[ a a a] a4 a a \[ r4 r2. \] \\bar \"||\" } " ,
  "\markup { \override #\'(font-name . \"Linux Libertine Capitals\") { Complete the following measures with rests: }} \\relative c''{ \override Rest #\'color = #red \\time 10/8 \override TextScript #'padding = #4.0 a8.[^\"3+2+2+3\" a16 a8] a4 \[ r4 r8 \] a4 a4 a8 \[ r4 r8 \] a8 a a4 a8[ a a] a \[ r8 r \] a8 a a4 \\bar \"||\" } " ,
  ]

# detect errors
DetectErrorsList = [
  " " ,
  "\\relative c'''{ \once \override Staff.Clef #'extra-offset = #'(0 . -1) \clef treble \set Staff.keySignature = #`(((0 . 7) . ,SHARP)((0 . 10) . ,SHARP)) \\time 4/2 a^\markup { Andente } g16 f[ e] d \\bar \"|\" a'4 g16[ f e] d \\bar \"|\" f,[ g] a8 g f \\bar \"|\" e a[ f] d^\markup { Bech } \\bar \"|.\" } " , 
  "\\relative c'''{ \set Staff.keySignature = #`(((0 . 9) . ,FLAT)((0 . 6) . ,FLAT))   \\time 9/8 a8^\markup { Cantabale } e f a d, e \\bar \"|.\" a c, d \\bar \"\" a' bes, c \\bar \"|\" a8. c16 bes a dis8 c bes bes^\markup { Bach } } " ,
  "\\relative c { \once \override Staff.Clef #'extra-offset = #'(0 . 1) \clef bass \set Staff.keySignature = #`(((0 . -4) . ,SHARP)((0 . -7) . ,SHARP)((0 . -3) . ,FLAT)) \\time 4/3 \override Staff.BarLine #'transparent = ##t a4.(^\markup { Serenade } b8 a c) ais4 b r b4.( c8[ b d]) bis4 c r^\markup { Brams } } " ,
  "\\relative c'{ \clef bass \\time 3/8 e8-.\pp[^\markup { Alligro vivache } d16] c d b \\bar \"\" c8-.[ a-.] \\bar \"|\" e-. a[ a16 a] a a a8 e[ c] a r r \\bar \"\" a r r \once \override TextScript #'padding = #3 a^\markup { Mendelssohn } r r\\fermata } " ,
  "\\relative c''{ \set Staff.keySignature = #`(((0 . 9) . ,SHARP)) \\time 4/2 \partial 4 b4 e,8 f[ g] a \\bar \"|\" b4 b c b8\stemDown a \\bar \"|\" b4 b \\bar \"|\" a b8] a \\bar \"|\" g4 g \\bar \"|\" f g8 f \\bar \"|\" e4 \\bar \"|.\" } " ,
  "\\new PianoStaff << \\new Staff { \\relative c''{ \once \override Staff.Clef #'extra-offset = #'(0 . 2) \clef treble \key c \minor \\time 4/4 \override TextScript #'staff-padding = #3 <g g'>2(^\"Sonata Op.13\" c4) c8( d) \\bar \"\" | \stemUp ees4-. ees8( f) d4-. d8( ees) \stemNeutral | c4-. bes'!2 bes4(~ \\bar \"\" | bes8 aes[ g] f ees[ d c b])^\markup { \\right-align \"Beethoven\" } | c8~ c <c c'>2 bes'!4~( \\bar \"\" | bes8[ aes g f] ees![ d c b]) | c4-. d^\\trill\\f( \grace { c16[ d] } ees4-.) <b d b'>4-. \\bar \"\" | <c ees c'>4-. r2 r4 \\bar \"||\" } } \\new Staff { \\relative c,{ \set Staff.keySignature = #`(((0 . -6) . ,FLAT)((0 . -3) . ,FLAT)((0 . -7) . ,FLAT)) \clef bass \\time 4/4 r8 e g c e g a fis \\bar \"\" | g, g' c g g, g' b! g | c,( c' b! c e,! c' g c \\bar \"\" | f, c' a c g f' b,! f') | a,[( e'] c[ e] g, e'! c e) \\bar \"\" | f,( f' c f g, g' g, g') | c,4-. <b! g>-. <c c,>-. <g g,>-. \\bar \"\" | <c, c,>-. r2 r4 \\bar \"||\" } } >> " , 
  "\\new PianoStaff << \\new Staff { \\relative c'{ \clef treble \key a \major \\time 3/4 \override TextScript #'staff-padding = #3 <cis a'>4.\p\(^\"Minuet I - Op.11\" <d b'>8 <cis a'> <e cis'>\) | \stemDown <cis ais'>4 <d b'> r \stemNeutral | <d b'>4.\( <e cis'>8 <d b'> <fis d'>\) | <dis bis'>4 <e cis'> r8 r | <e cis'>4.\( <fis d'>8 <e cis'> <g e'>\)^\markup { \\right-align \"Brahms\" }  \\break | <g e'>4-.\( <fis d'>-. <e cis'>-.\) | <<{ b'8~[ b] fis8\( gis a b\) | a4 gis r | fis cis8\( dis e fis\) | b,2. \\bar \"|.\" } \\\{ dis2. | d? | cis | b4\( a gis\) \\bar \"|.\" }>> } } \\new Staff { \\transpose c d { \\relative c { \once \override Staff.Clef #'extra-offset = #'(0 . -1) \clef bass \key g \major \\time 3/4 g8-. d'-. g,-. d'-. g,-. d'-. | g,-. d'-. g,-. e'-. g,-. e'-. | g,-. e'-.[ g,-. e'-.] g,-. e'-. | g,-. e'-. g,-. f'-. g,-. f'-. | g,-.\< f'-. g,-. f'-. g,-. g'-.\! | g,-.\> g'-. g,-. g'-. g,-. g'-.\! | g,-. e'-. g,-. e'-. g,-. e'-. | g,-. dis'-. g,-. dis'-. g,-. dis'-. | g,-. e'-. g,-. e'-. g,-. cis-. | fis,-. d'-. e,-. cis'-. d,-. d'-. \\bar \"|.\" } } } >> " ,
  "\\new PianoStaff << \\new Staff { \\relative c''{ \once \override Staff.Clef #'extra-offset = #'(0 . 2) \\time 2/2 \key ees \major \partial 4. g8-.\p c-. d-. ees4.( f8 d4. ees8) c2 \grace d8 c8( b c d \grace f8 ees8 d ees f) g4-. g-. g4~ g~ g f8( g) \grace { f16[( g]) } a2( d,4) ees8( f) \grace { ees16[( f]) } g2( c,4) c8( d) \stemUp ees4-. \stemNeutral ees8( f) d4-. d8( ees) \\bar \"|.\" } } \\new Staff { \\relative c{ \clef bass \\time 2/2 \set Staff.keySignature = #`(((0 . -8) . ,FLAT)((0 . -5) . ,FLAT)((0 . -10) . ,FLAT))  r4 r8 c8( e g c) c,( f g b) c,( e g c) e g e d c[ g' <e c>] g <d b> g <c, aes> g' g, b d g g, b d g f,( aes b d) f,( aes b d) e,( g c e) aes,( c e fis) g,( c e g) g,( b d g) } } >> " ,
  "setup = { \key c \minor } oneone = { \\relative c''' { R1 R r8 g16( fis g8-.) c,-. es-.  g16( fis? g8-.) a-. } } onetwo = { \\relative c''' { d,-. g16( fis g8-.) a-. c,16( d es4-> d16 c bes8-.) es16( d es8-.) g,-. aes?-. f'16( es f8-.) a,-. bes-. g'16( f g8-.) b,-. c-. d16( es f4->)~ } } onethree = { \\relative c'' { \set Staff.keySignature = #`(((0 . 6) . ,FLAT)((0 . 9) . ,SHARP)((0 . 5) . ,FLAT))  f8( e16 d c bes? aes g f8-.)[ a'(] g-.) f-. e-.[ d(] e-.) f-. bes,-.[ c(] d-.) bes-. c-. g'16( fis g8-.) d-. e4 r8 e-. \\bar \"|.\" } } twoone = { \\relative c'' { r8 c16( b \stemUp c8-.) g-. \stemDown aes-. c16( b c8-.) d-. g,-. c16( b c8-.) d16~ d f,16( g aes4-> g16 f es-.) c'( b a g f es d) c8-.[ es'(] d-.) c-. } } twotwo = { \\relative c'' { bes?-.[ a(] bes-.) c-. fis,([ g] a? fis g4) r16 c,( d es f? g aes8->)~ aes16 d,( es f g a bes8->)~ bes16 es,( f g aes g f es) d8-. c'16 b } } twothree = { \\relative c'' { c4 r8 r4 f8 e[ d] r aes g[ f-.] g-. f16( e f8-.) d-. g4 r8 bes-. c-. c16( bes c8-.) g-. } } threeone = { \\relative c' { R1 | R | R } } threetwo = { \\relative c' { \once \override Staff.Clef #'rotation = #'(180 0 0) R | R | R } } threethree = { \\relative c' { r8 c16( b c8-.) g-. aes-. c16( b? c8-.) d-. g,-. c16( b c8-.) d-. f,16( g aes4-> g16 f es-.) c'( b a g f es d c d es d c bes aes g) } } \\new PianoStaff << \\new Staff { \setup <<{ \oneone } \\\{ \\twoone }>> } \\new Staff { \clef bass \setup \\threeone } >> \\new PianoStaff << \\new Staff { \\notimesig \setup <<{ \onetwo } \\\{ \\twotwo }>> } \\new Staff { \\notimesig \clef bass \setup \\threetwo } >> \\new PianoStaff << \\new Staff { \\notimesig \setup <<{ \onethree } \\\{ \\twothree }>> } \\new Staff { \\notimesig \clef bass \setup \\threethree } >> " ,
  ]
DetectErrorsKeyList = [
  " " ,
  "\\relative c'''{ \clef treble \key d \major \\time 2/4 a^\markup { Andante } g16 fis e d \\bar \"|\" a'4 g16 fis e d \\bar \"|\" fis, g a8 g fis \\bar \"|\" e a fis d^\markup { Bach } \\bar \"|.\" } " , 
  "\\relative c'''{ \key bes \major \\time 6/8 a8^\markup { Cantabile } es f a d, es a c, d a' bes, c a8. c16 bes a dis8 c bes bes^\markup { Bach } } " ,
  "\\relative c { \clef bass \key a \major \\time 3/4 a4.(^\markup { Serenade } b8 a cis) ais4 b r b4.( cis8[ b d]) bis4 cis r^\markup { Brahms } } " ,
  "\\relative c'{ \clef bass \\time 3/8 e8-.\pp^\markup { Allegro vivace } d16 c d b c8-. a-. e-. a a16 a a a a8 e c a r r a r r \once \override TextScript #'padding = #3 a^\markup { Mendelssohn } r r\\fermata } " ,
  "\\relative c''{ \key e \minor \\time 2/4 \partial 4 b4 e,8 fis g a b4 b c b8 a  b4 b a b8 a g4 g fis g8 fis e4 \\bar \"|.\" } " ,
  "\\new PianoStaff << \\new Staff { \\relative c''{ \clef treble \key c \minor \\time 4/4 \override TextScript #'staff-padding = #3 <g g'>2(^\"Sonata Op.13\" c4) c8( d) es4-. es8( f) d4-. d8( es) c4-. bes'2 bes4(~ bes8 aes g f ees d c b)^\markup { \\right-align \"Beethoven\" } c4 <c c'>2 bes'4~( bes8 aes g f es d c b) c4-. d^\\trill\\f( \grace { c16[ d] } ees4-.) <b d b'>4-. <c ees c'>4-. r2 r4 \\bar \"||\" } } \\new Staff { \\relative c,{ \key c \minor \clef bass \\time 4/4 r8 es g c es g aes fis  g, g' c g g, g' b g  c,( c' b c e, c' g c f, c' aes c g f' b, f') aes,( es' c es g, e' c e) f,( f' c f g, g' g, g') c,4-. <b g>-. <c c,>-. <g g,>-. <c, c,>-. r2 r4 \\bar \"||\" } } >> " , 
  "\\new PianoStaff << \\new Staff { \\relative c'{ \clef treble \key a \major \\time 3/4 \override TextScript #'staff-padding = #3 <cis a'>4.\p\(^\"Minuet I - Op.11\" <d b'>8 <cis a'> <e cis'>\) <cis ais'>4 <d b'> r <d b'>4.\( <e cis'>8 <d b'> <fis d'>\) <dis bis'>4 <e cis'> r4 <e cis'>4.\( <fis d'>8 <e cis'> <g e'>\)^\markup { \\right-align \"Brahms\" }  \\break <g e'>4-.\( <fis d'>-. <e cis'>-.\) <<{ b'4 fis8\( gis a b\) a4 gis r fis cis8\( dis e fis\) b,2. \\bar \"|.\" } \\\{ dis2. | d? cis b4\( a gis\) \\bar \"|.\" }>> } } \\new Staff { \\transpose c d { \\relative c { \clef bass \key g \major \\time 3/4 g8-. d'-. g,-. d'-. g,-. d'-. g,-. d'-. g,-. e'-. g,-. e'-.  g,-. e'-. g,-. e'-. g,-. e'-.  g,-. e'-. g,-. f'-. g,-. f'-.  g,-.\< f'-. g,-. f'-. g,-. g'-.\! g,-.\> g'-. g,-. g'-. g,-. g'-.\! g,-. e'-. g,-. e'-. g,-. e'-. g,-. dis'-. g,-. dis'-. g,-. dis'-. g,-. e'-. g,-. e'-. g,-. cis-. fis,-. d'-. e,-. cis'-. d,-. d'-. \\bar \"|.\" } } } >> " ,
  "\\new PianoStaff << \\new Staff { \\relative c''{ \\time 2/2 \key ees \major \partial 4. g8-.\p c-. d-. ees4.( f8 d4. ees8) c2 \grace d8 c8( b c d \grace f8 ees8 d ees f) g4-. g-. g2. f8( g) \grace { f16[( g]) } a2( d,4) ees8( f) \grace { ees16[( f]) } g2( c,4) c8( d) ees4-. ees8( f) d4-. d8( ees) \\bar \"|.\" } } \\new Staff { \\relative c{ \clef bass \\time 2/2 \key ees \major r4 r8 c8( es g c) c,( f g bes) c,( es g c) es g es d c g' <es c> g <d bes> g <c, aes> g' g, bes d g g, bes d g f,( aes bes d) f,( aes bes d) es,( g c es) aes,( c es fis) g,( c es g) g,( bes d g) } } >> " ,
  "setup = { \key c \minor } oneone = { \\relative c''' { R1 R r8 g16( fis g8-.) c,-. es-.  g16( fis? g8-.) a-. } } onetwo = { \\relative c''' { d,-. g16( fis g8-.) a-. c,16( d es4-> d16 c bes8-.) es16( d es8-.) g,-. aes?-. f'16( es f8-.) a,-. bes-. g'16( f g8-.) b,-. c-. d16( es f4->)~ } } onethree = { \\relative c'' { f8( e16 d c bes? aes g f8-.) a'( g-.) f-. e-. d( e-.) f-. bes,-. c( d-.) bes-. c-. g'16( fis g8-.) d-. e4 r8 e-. \\bar \"|.\" } } twoone = { \\relative c'' { r8 c16( b c8-.) g-. aes-. c16( b c8-.) d-. g,-. c16( b c8-.) d8 f,16( g aes4-> g16 f es-.) c'( b a g f es d) c8-. es'( d-.) c-. } } twotwo = { \\relative c'' { bes?-. a( bes-.) c-. fis,( g a? fis g4) r16 c,( d es f? g aes8->)~ aes16 d,( es f g a bes8->)~ bes16 es,( f g aes g f es) d8-. c'16 b } } twothree = { \\relative c'' { c4 r8 r4 f8 e d r aes g f-. g-. f16( e f8-.) d-. g4 r8 bes-. c-. c16( bes c8-.) g-. } } threeone = { \\relative c' { R1 R R } } threetwo = { \\relative c' { R R R } } threethree = { \\relative c' { r8 c16( b c8-.) g-. aes-. c16( b? c8-.) d-. g,-. c16( b c8-.) d-. f,16( g aes4-> g16 f es-.) c'( b a g f es d c d es d c bes aes g) } } \\new PianoStaff << \\new Staff { \setup <<{ \oneone } \\\{ \\twoone }>> } \\new Staff { \clef bass \setup \\threeone } >> \\new PianoStaff << \\new Staff { \\notimesig \setup <<{ \onetwo } \\\{ \\twotwo }>> } \\new Staff { \\notimesig \clef bass \setup \\threetwo } >> \\new PianoStaff << \\new Staff { \\notimesig \setup <<{ \onethree } \\\{ \\twothree }>> } \\new Staff { \\notimesig \clef bass \setup \\threethree } >> " ,
  ]




##################################################
# FUNCTIONS
##################################################

### HEADERS
##################################################
def lilypondHeaders(f,g,title,copyright):
  f.writelines(headera + headersheeta + [title] + headersheetb + headerb + [copyright] + headerc)
  g.writelines(headera + headerkeya + [title] + headerkeyb + headerb + [copyright] + headerc)

### Aural Intervals
##################################################
def AuralIntervals(f,g,howmanytimes):
  # sheet
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { \large \\bold "1. Name the following intervals:" } } \\noPageBreak\n')
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { ')
  if howmanytimes < 11:
    for i in range(howmanytimes):
      x = i + 1
      f.write( str(x) +  '. ___ ')
    f.write(' }}\n')
  else:
    for i in range(10):
      x = i + 1
      f.write( str(x) +  '. ___ ')
    f.write(' }}\n')
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { ')
    for i in range(10,howmanytimes):
      x = i + 1
      f.write( str(x) +  '. ___ ')
    f.write(' }}\n')
  # key
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { \large \\bold "1. Name the following intervals:" }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { ')
  if howmanytimes < 11:
    for i in range(howmanytimes):
      x = i + 1
      g.write( str(x) +  '. \with-color #red ' + random.choice(auralIntervals) + ' \hspace #2 ')
    g.write(' }}\n')
  else:
    for i in range(10):
      x = i + 1
      g.write( str(x) +  '. ___ ')
    g.write(' }\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { ')
    for i in range(10,howmanytimes):
      x = i + 1
      g.write( str(x) +  '. ___ ')
    g.write(' }} \n')

### Drawing Clefs
##################################################
def DrawClefs(f,g,howmanytimes):
  # sheet
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { \large \\bold { Write out the following clefs ' + str(howmanytimes) + ' times.}}} \\noPageBreak \n')
  f.write('{ \\nobarline \clef treble \\notimesig s1 }\n')
  f.write('{ \\nobarline \clef bass \\notimesig s1 }\n')
  f.write('{ \\nobarline \clef alto \\notimesig s1 }\n')
  f.write('{ \\nobarline \clef tenor \\notimesig s1 }\n')
  # key
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { \large \\bold { Write out the following clefs ' + str(howmanytimes) + ' times.}}} \\noPageBreak \n')
  g.write('{ \\nobarline \\notimesig \\noclefresize \clef treble ')
  for i in range(howmanytimes):
    g.write(' s8 \set Staff.forceClef = ##t \override Staff.Clef #\'color = #(rgb-color 1.0 0.0 0.0) \clef treble ')
  g.write(' }\n')
  g.write('{ \\nobarline \\notimesig \\noclefresize \clef bass ')
  for i in range(howmanytimes):
    g.write(' s8 \set Staff.forceClef = ##t \override Staff.Clef #\'color = #(rgb-color 1.0 0.0 0.0) \clef bass ')
  g.write(' }\n')
  g.write('{ \\nobarline \\notimesig \\noclefresize \clef alto ')
  for i in range(howmanytimes):
    g.write(' s8 \set Staff.forceClef = ##t \override Staff.Clef #\'color = #(rgb-color 1.0 0.0 0.0) \clef alto ')
  g.write(' }\n')
  g.write('{ \\nobarline \\notimesig \\noclefresize \clef tenor ')
  for i in range(howmanytimes):
    g.write(' s8 \set Staff.forceClef = ##t \override Staff.Clef #\'color = #(rgb-color 1.0 0.0 0.0) \clef tenor ')
  g.write(' }\n')

### Writing Notes
##################################################
def WriteNotes(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { \large \\bold "Write out the following notes." (L = on a line, S = on a space) }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { \large \\bold "Write out the following notes." (L = on a line, S = on a space) }} \\noPageBreak\n')
  f.write('{ \clef treble \\notimesig \\nobarline \\nobarlinenumbers \override TextScript #\'padding = #3 ')
  g.write('{ \clef treble \\notimesig \\nobarline \\nobarlinenumbers \override TextScript #\'padding = #3 ')
  temp = list(range(len(WrittenNoteNames)))
  for i in range(howmanytimes):
    if not temp:
      temp = list(range(len(WrittenNoteNames)))
    x = random.choice(temp)
    temp.remove(x)
    f.write('s1_\markup { \override #\'(font-name . "Linux Libertine Capitals") { ' + WrittenNoteNames[x] + ' }}')
    g.write('\override NoteHead #\'color = #red ' + WrittenNoteNamesKeyTreble[x] + '1_\markup { \override #\'(font-name . "Linux Libertine Capitals") { ' + WrittenNoteNames[x] + ' }}')
  f.write(' }')
  g.write(' }')
  f.write('{ \clef bass \\notimesig \\nobarline \\nobarlinenumbers \override TextScript #\'padding = #3 ')
  g.write('{ \clef bass \\notimesig \\nobarline \\nobarlinenumbers \override TextScript #\'padding = #3 ')
  temp = list(range(len(WrittenNoteNames)))
  for i in range(howmanytimes):
    if not temp:
      temp = list(range(len(WrittenNoteNames)))
    x = random.choice(temp)
    temp.remove(x)
    f.write('s1_\markup { \override #\'(font-name . "Linux Libertine Capitals") { ' + WrittenNoteNames[x] + ' }}')
    g.write('\override NoteHead #\'color = #red ' + WrittenNoteNamesKeyBass[x] + '1_\markup { \override #\'(font-name . "Linux Libertine Capitals") { ' + WrittenNoteNames[x] + ' }}')
  f.write(' }')
  g.write(' }')
  f.write('{ \clef alto \\notimesig \\nobarline \\nobarlinenumbers \override TextScript #\'padding = #3 ')
  g.write('{ \clef alto \\notimesig \\nobarline \\nobarlinenumbers \override TextScript #\'padding = #3 ')
  temp = list(range(len(WrittenNoteNames)))
  for i in range(howmanytimes):
    if not temp:
      temp = list(range(len(WrittenNoteNames)))
    x = random.choice(temp)
    temp.remove(x)
    f.write('s1_\markup { \override #\'(font-name . "Linux Libertine Capitals") { ' + WrittenNoteNames[x] + ' }}')
    g.write('\override NoteHead #\'color = #red ' + WrittenNoteNamesKeyAlto[x] + '1_\markup { \override #\'(font-name . "Linux Libertine Capitals") { ' + WrittenNoteNames[x] + ' }}')
  f.write(' }')
  g.write(' }')
  f.write('{ \clef tenor \\notimesig \\nobarline \\nobarlinenumbers \override TextScript #\'padding = #3 ')
  g.write('{ \clef tenor \\notimesig \\nobarline \\nobarlinenumbers \override TextScript #\'padding = #3 ')
  temp = list(range(len(WrittenNoteNames)))
  for i in range(howmanytimes):
    if not temp:
      temp = list(range(len(WrittenNoteNames)))
    x = random.choice(temp)
    temp.remove(x)
    f.write('s1_\markup { \override #\'(font-name . "Linux Libertine Capitals") { ' + WrittenNoteNames[x] + ' }}')
    g.write('\override NoteHead #\'color = #red ' + WrittenNoteNamesKeyTenor[x] + '1_\markup { \override #\'(font-name . "Linux Libertine Capitals") { ' + WrittenNoteNames[x] + ' }}')
  f.write(' }\n')
  g.write(' }\n')

def IdentifyNotes(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { \large \\bold "Name the following notes." }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { \large \\bold "Name the following notes." }} \\noPageBreak\n')
  f.write('{ \clef treble \\notimesig \\nobarline \\nobarlinenumbers \override TextScript #\'padding = #4 ')
  g.write('{ \clef treble \\notimesig \\nobarline \\nobarlinenumbers \override TextScript #\'padding = #4 ')
  temp = list(range(len(IdentifyNoteNamesTreble)))
  for i in range(howmanytimes):
    if not temp:
      temp = list(range(len(IdentifyNoteNamesTreble)))
    x = random.choice(temp)
    temp.remove(x)
    f.write( IdentifyNoteNamesTreble[x] + '_\markup { \override #\'(font-name . "Linux Libertine Capitals") { ___ }} ')
    g.write( IdentifyNoteNamesTreble[x] + '_\markup { \with-color #red \override #\'(font-name . "Linux Libertine Capitals") { ' + IdentifyNoteNamesTrebleKey[x] + ' }} ')
  f.write(' }\n')
  g.write(' }\n')
  f.write('{ \clef bass \\notimesig \\nobarline \\nobarlinenumbers \override TextScript #\'padding = #4 ')
  g.write('{ \clef bass \\notimesig \\nobarline \\nobarlinenumbers \override TextScript #\'padding = #4 ')
  temp = list(range(len(IdentifyNoteNamesBass)))
  for i in range(howmanytimes):
    if not temp:
      temp = list(range(len(IdentifyNoteNamesBass)))
    x = random.choice(temp)
    temp.remove(x)
    f.write( IdentifyNoteNamesBass[x] + '_\markup { \override #\'(font-name . "Linux Libertine Capitals") { ___ }} ')
    g.write( IdentifyNoteNamesBass[x] + '_\markup { \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red ' + IdentifyNoteNamesBassKey[x] + ' }} ')
  f.write(' }\n')
  g.write(' }\n')
  f.write('{ \clef alto \\notimesig \\nobarline \\nobarlinenumbers \override TextScript #\'padding = #4 ')
  g.write('{ \clef alto \\notimesig \\nobarline \\nobarlinenumbers \override TextScript #\'padding = #4 ')
  temp = list(range(len(IdentifyNoteNamesAlto)))
  for i in range(howmanytimes):
    if not temp:
      temp = list(range(len(IdentifyNoteNamesAlto)))
    x = random.choice(temp)
    temp.remove(x)
    f.write( IdentifyNoteNamesAlto[x] + '_\markup { \override #\'(font-name . "Linux Libertine Capitals") { ___ }} ')
    g.write( IdentifyNoteNamesAlto[x] + '_\markup { \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red ' + IdentifyNoteNamesAltoKey[x] + ' }} ')
  f.write(' }\n')
  g.write(' }\n')
  f.write('{ \clef tenor \\notimesig \\nobarline \\nobarlinenumbers \override TextScript #\'padding = #4 ')
  g.write('{ \clef tenor \\notimesig \\nobarline \\nobarlinenumbers \override TextScript #\'padding = #4 ')
  temp = list(range(len(IdentifyNoteNamesTenor)))
  for i in range(howmanytimes):
    if not temp:
      temp = list(range(len(IdentifyNoteNamesTenor)))
    x = random.choice(temp)
    temp.remove(x)
    f.write( IdentifyNoteNamesTenor[x] + '_\markup { \override #\'(font-name . "Linux Libertine Capitals") { ___ }} ')
    g.write( IdentifyNoteNamesTenor[x] + '_\markup { \override #\'(font-name . "Lin     ux Libertine Capitals") { \with-color #red ' + IdentifyNoteNamesTenorKey[x] + ' }} ')
  f.write(' }\n')
  g.write(' }\n')

### Durations
##################################################
def WriteASingleNoteEqualTo(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write a single note equal to: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write a single note equal to: }} \\noPageBreak\n')
  f.write('{ \stopStaff \\noclef \\notimesig \\nobarlinenumbers \cadenzaOn \\autoBeamOff \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 3 \n')
  g.write('{ \stopStaff \\noclef \\notimesig \\nobarlinenumbers \cadenzaOn \\autoBeamOff \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 3 \n')
  temp = list(range(len(DurationSingleNoteEqualTo)))
  for i in range(howmanytimes):
    if i in [ 3 , 6 , 9 , 12 , 15 , 18 , 21 ]:
      f.write(' \\break ')
      g.write(' \\break ')
    if not temp:
      temp = list(range(len(DurationSingleNoteEqualTo)))
    x = random.choice(temp)
    temp.remove(x)
    f.write(DurationSingleNoteEqualTo[x] + ' \hideNotes a\'_\markup { \override #\'(font-name . "Linux Libertine Capitals") { = }}  c\'\'1_\markup { \hspace #1 \override #\'(box-padding . 1.5) \\box \hspace #1  } \\unHideNotes s1 \\bar ""\n')
    g.write(DurationSingleNoteEqualTo[x] + ' \hideNotes a\'_\markup { \override #\'(font-name . "Linux Libertine Capitals") { = }}  \\unHideNotes \once \override NoteHead #\'color = #red \once \override Stem #\'color = #red \once \override Dots #\'color = #red \once \override Flag #\'color = #red ' + DurationSingleNoteEqualToKey[x] + ' s1 \\bar ""\n')
  f.write('}\n')
  g.write('}\n')

def WriteASingleRestEqualTo(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write a single rest equal to: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write a single rest equal to: }} \\noPageBreak\n')
  f.write('{ \stopStaff \\noclef \\notimesig \\nobarlinenumbers \cadenzaOn \\autoBeamOff \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 3 \n')
  g.write('{ \stopStaff \\noclef \\notimesig \\nobarlinenumbers \cadenzaOn \\autoBeamOff \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 3 \n')
  temp = list(range(len(DurationSingleRestEqualTo)))
  for i in range(howmanytimes):
    if i in [ 3 , 6 , 9 , 12 , 15 , 18 , 21 ]:
      f.write(' \\break ')
      g.write(' \\break ')
    if not temp:
      temp = list(range(len(DurationSingleRestEqualTo)))
    x = random.choice(temp)
    temp.remove(x)
    f.write(DurationSingleRestEqualTo[x] + ' \hideNotes a\'_\markup { \override #\'(font-name . "Linux Libertine Capitals") { = }}  c\'\'1_\markup { \hspace #1 \override #\'(box-padding . 1.5) \\box \hspace #1  } \\unHideNotes s1 \\bar ""\n')
    g.write(DurationSingleRestEqualTo[x] + ' \hideNotes a\'_\markup { \override #\'(font-name . "Linux Libertine Capitals") { = }}  \\unHideNotes \once \override Rest #\'color = #red \once \override Dots #\'color = #red ' + DurationSingleRestEqualToKey[x] + ' s1 \\bar ""\n')
  f.write('}\n')
  g.write('}\n')

def WriteTwoNotesEqualTo(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write two of the same notes equal to: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write two of the same notes equal to: }} \\noPageBreak\n')
  f.write('{ \stopStaff \\noclef \\notimesig \\nobarlinenumbers \cadenzaOn \\autoBeamOff \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 2 \n')
  g.write('{ \stopStaff \\noclef \\notimesig \\nobarlinenumbers \cadenzaOn \\autoBeamOff \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 2 \n')
  temp = list(range(len(DurationTwoNotesEqualTo)))
  for i in range(howmanytimes):
    if i in [ 3 , 6 , 9 , 12 , 15 , 18 , 21 ]:
      f.write(' \\break ')
      g.write(' \\break ')
    if not temp:
      break
    x = random.choice(temp)
    temp.remove(x)
    f.write(DurationTwoNotesEqualTo[x] + ' \hideNotes a\'_\markup { \override #\'(font-name . "Linux Libertine Capitals") { = }}  c\'\'1_\markup { \hspace #1 \override #\'(box-padding . 1.5) \\box \hspace #1  } \\unHideNotes s1 \\bar ""\n')
    g.write(DurationTwoNotesEqualTo[x] + ' \hideNotes a\'_\markup { \override #\'(font-name . "Linux Libertine Capitals") { = }}  \\unHideNotes \once \override NoteHead #\'color = #red \once \override Stem #\'color = #red \once \override Dots #\'color = #red \once \override Flag #\'color = #red ' + DurationTwoNotesEqualToKey[x] + ' \once \override NoteHead #\'color = #red \once \override Stem #\'color = #red \once \override Dots #\'color = #red \once \override Flag #\'color = #red ' + DurationTwoNotesEqualToKey[x] + ' s1 \\bar ""\n')
  f.write('}\n')
  g.write('}\n')

def WriteTwoRestsEqualTo(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write two of the same rests equal to: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write two of the same rests equal to: }} \\noPageBreak\n')
  f.write('{ \stopStaff \\noclef \\notimesig \\nobarlinenumbers \cadenzaOn \\autoBeamOff \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 2 \n')
  g.write('{ \stopStaff \\noclef \\notimesig \\nobarlinenumbers \cadenzaOn \\autoBeamOff \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 2 \n')
  temp = list(range(len(DurationTwoRestsEqualTo)))
  for i in range(howmanytimes):
    if i in [ 3 , 6 , 9 , 12 , 15 , 18 , 21 ]:
      f.write(' \\break ')
      g.write(' \\break ')
    if not temp:
      break
    x = random.choice(temp)
    temp.remove(x)
    f.write(DurationTwoRestsEqualTo[x] + ' \hideNotes a\'_\markup { \override #\'(font-name . "Linux Libertine Capitals") { = }}  c\'\'1_\markup { \hspace #1 \override #\'(box-padding . 1.5) \\box \hspace #1  } \\unHideNotes s1 \\bar ""\n')
    g.write(DurationTwoRestsEqualTo[x] + ' \hideNotes a\'_\markup { \override #\'(font-name . "Linux Libertine Capitals") { = }}  \\unHideNotes \once \override Rest #\'color = #red \once \override Dots #\'color = #red ' + DurationTwoRestsEqualToKey[x] + ' \once \override Rest #\'color = #red \once \override Dots #\'color = #red ' + DurationTwoRestsEqualToKey[x] + ' s1 \\bar ""\n')
  f.write('}\n')
  g.write('}\n')

def WriteThreeNotesEqualTo(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write three of the same notes equal to: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write three of the same notes equal to: }} \\noPageBreak\n')
  f.write('{ \stopStaff \\noclef \\notimesig \\nobarlinenumbers \cadenzaOn \\autoBeamOff \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 2 \n')
  g.write('{ \stopStaff \\noclef \\notimesig \\nobarlinenumbers \cadenzaOn \\autoBeamOff \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 2 \n')
  temp = list(range(len(DurationThreeNotesEqualTo)))
  for i in range(howmanytimes):
    if i in [ 3 , 6 , 9 , 12 , 15 , 18 , 21 ]:
      f.write(' \\break ')
      g.write(' \\break ')
    if not temp:
      break
    x = random.choice(temp)
    temp.remove(x)
    f.write(DurationThreeNotesEqualTo[x] + ' \hideNotes a\'_\markup { \override #\'(font-name . "Linux Libertine Capitals") { = }}  c\'\'1_\markup { \hspace #1 \override #\'(box-padding . 1.5) \\box \hspace #1  } \\unHideNotes s1 \\bar ""\n')
    g.write(DurationThreeNotesEqualTo[x] + ' \hideNotes a\'_\markup { \override #\'(font-name . "Linux Libertine Capitals") { = }}  \\unHideNotes \once \override NoteHead #\'color = #red \once \override Stem #\'color = #red \once \override Dots #\'color = #red \once \override Flag #\'color = #red ' + DurationThreeNotesEqualToKey[x] + ' \once \override NoteHead #\'color = #red \once \override Stem #\'color = #red \once \override Dots #\'color = #red \once \override Flag #\'color = #red ' + DurationThreeNotesEqualToKey[x] + ' \once \override NoteHead #\'color = #red \once \override Stem #\'color = #red \once \override Dots #\'color = #red \once \override Flag #\'color = #red ' + DurationThreeNotesEqualToKey[x] + ' s1 \\bar ""\n')
  f.write('}\n')
  g.write('}\n')

def WriteThreeRestsEqualTo(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write three of the same rests equal to: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write three of the same rests equal to: }} \\noPageBreak\n')
  f.write('{ \stopStaff \\noclef \\notimesig \\nobarlinenumbers \cadenzaOn \\autoBeamOff \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 2 \n')
  g.write('{ \stopStaff \\noclef \\notimesig \\nobarlinenumbers \cadenzaOn \\autoBeamOff \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 2 \n')
  temp = list(range(len(DurationThreeRestsEqualTo)))
  for i in range(howmanytimes):
    if i in [ 3 , 6 , 9 , 12 , 15 , 18 , 21 ]:
      f.write(' \\break ')
      g.write(' \\break ')
    if not temp:
      break
    x = random.choice(temp)
    temp.remove(x)
    f.write(DurationThreeRestsEqualTo[x] + ' \hideNotes a\'_\markup { \override #\'(font-name . "Linux Libertine Capitals") { = }}  c\'\'1_\markup { \hspace #1 \override #\'(box-padding . 1.5) \\box \hspace #1  } \\unHideNotes s1 \\bar ""\n')
    g.write(DurationThreeRestsEqualTo[x] + ' \hideNotes a\'_\markup { \override #\'(font-name . "Linux Libertine Capitals") { = }}  \\unHideNotes \once \override Rest #\'color = #red \once \override Dots #\'color = #red ' + DurationThreeRestsEqualToKey[x] + ' \once \override Rest #\'color = #red \once \override Dots #\'color = #red ' + DurationThreeRestsEqualToKey[x] + ' \once \override Rest #\'color = #red \once \override Dots #\'color = #red ' + DurationThreeRestsEqualToKey[x] + ' s1 \\bar ""\n')
  f.write('}\n')
  g.write('}\n')

def CompareDurations(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Fill in the blanks: }} \\noPageBreak\n\markup{ }\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Fill in the blanks: }} \\noPageBreak\n\markup{ }\n')
  temp = list(range(len(DurationComparisons)))
  for i in range(howmanytimes):
    if not temp:
      break
    x = random.choice(temp)
    temp.remove(x)
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { ' + DurationComparisons[x] + ' }}\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { ' + DurationComparisonsKey[x] + ' }}\n')

### CST DST WT
##################################################
def IdentifyCstDstWt(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Label the following as CST (chromatic semitone), DST (diatonic semitone) or WT (wholetone): }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Label the following as CST (chromatic semitone), DST (diatonic semitone) or WT (wholetone): }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = ' ' if identclef == 'treble' else ',' if identclef == 'alto' else ',' if identclef == 'tenor' else ',,'
  f.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 ')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  temp = list(range(len(IdentifyCstDstWtNotes)))
  for i in range(howmanytimes):
    if not temp:
      break
    x = random.choice(temp)
    temp.remove(x)
    f.write( IdentifyCstDstWtNotes[x] + ' \\bar "|" ')
    g.write( IdentifyCstDstWtNotes[x] + '^\markup { \\right-align \with-color #red \override #\'(font-name . "Linux Libertine Capitals") { ' + IdentifyCstDstWtNotesKey[x] + ' }} \\bar "|" ')
  f.write(' }\n')
  g.write(' }\n')

def WriteCstAbove(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write a chromatic semitone above the following notes: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write a chromatic semitone above the following notes: }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = ' ' if identclef == 'treble' else ',' if identclef == 'alto' else ',' if identclef == 'tenor' else ',,'
  f.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 1 ')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 ')
  temp = list(range(len(WriteAboveCstNotes)))
  for i in range(howmanytimes):
    if not temp:
      temp = list(range(len(WriteAboveCstNotes)))
    x = random.choice(temp)
    temp.remove(x)
    f.write( WriteAboveCstNotes[x] + ' ')
    g.write( WriteAboveCstNotesKey[x] + ' ')
  f.write(' }\n')
  g.write(' }\n')

def WriteDstAbove(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write a diatonic semitone above the following notes: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write a diatonic semitone above the following notes: }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = ' ' if identclef == 'treble' else ',' if identclef == 'alto' else ',' if identclef == 'tenor' else ',,'
  f.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 1 ')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 ')
  temp = list(range(len(WriteAboveDstNotes)))
  for i in range(howmanytimes):
    if not temp:
      temp = list(range(len(WriteAboveDstNotes)))
    x = random.choice(temp)
    temp.remove(x)
    f.write( WriteAboveDstNotes[x] + ' ')
    g.write( WriteAboveDstNotesKey[x] + ' ')
  f.write(' }\n')
  g.write(' }\n')

def WriteWtAbove(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write a wholetone above the following notes: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write a wholetone above the following notes: }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = ' ' if identclef == 'treble' else ',' if identclef == 'alto' else ',' if identclef == 'tenor' else ',,'
  f.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 1 ')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 ')
  temp = list(range(len(WriteAboveWtNotes)))
  for i in range(howmanytimes):
    if not temp:
      temp = list(range(len(WriteAboveWtNotes)))
    x = random.choice(temp)
    temp.remove(x)
    f.write( WriteAboveWtNotes[x] + ' ')
    g.write( WriteAboveWtNotesKey[x] + ' ')
  f.write(' }\n')
  g.write(' }\n')

def WriteCstBelow(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write a chromatic semitone below the following notes: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write a chromatic semitone below the following notes: }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = ' ' if identclef == 'treble' else ',' if identclef == 'alto' else ',' if identclef == 'tenor' else ',,'
  f.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 1 ')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 ')
  temp = list(range(len(WriteBelowCstNotes)))
  for i in range(howmanytimes):
    if not temp:
      temp = list(range(len(WriteBelowCstNotes)))
    x = random.choice(temp)
    temp.remove(x)
    f.write( WriteBelowCstNotes[x] + ' ')
    g.write( WriteBelowCstNotesKey[x] + ' ')
  f.write(' }\n')
  g.write(' }\n')

def WriteDstBelow(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write a diatonic semitone below the following notes: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write a diatonic semitone below the following notes: }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = ' ' if identclef == 'treble' else ',' if identclef == 'alto' else ',' if identclef == 'tenor' else ',,'
  f.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 1 ')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 ')
  temp = list(range(len(WriteBelowDstNotes)))
  for i in range(howmanytimes):
    if not temp:
      temp = list(range(len(WriteBelowDstNotes)))
    x = random.choice(temp)
    temp.remove(x)
    f.write( WriteBelowDstNotes[x] + ' ')
    g.write( WriteBelowDstNotesKey[x] + ' ')
  f.write(' }\n')
  g.write(' }\n')

def WriteWtBelow(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write a wholetone below the following notes: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write a wholetone below the following notes: }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = ' ' if identclef == 'treble' else ',' if identclef == 'alto' else ',' if identclef == 'tenor' else ',,'
  f.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 1 ')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 ')
  temp = list(range(len(WriteBelowWtNotes)))
  for i in range(howmanytimes):
    if not temp:
      temp = list(range(len(WriteBelowWtNotes)))
    x = random.choice(temp)
    temp.remove(x)
    f.write( WriteBelowWtNotes[x] + ' ')
    g.write( WriteBelowWtNotesKey[x] + ' ')
  f.write(' }\n')
  g.write(' }\n')

def WriteEnharmonic(f,g):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write an enharmonic spelling for the following notes: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write an enharmonic spelling for the following notes: }} \\noPageBreak\n')
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { ')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { ')
  temp = list(range(len(EnharmonicNotes)))
  for i in range(8):
     x = random.choice(temp)
     temp.remove(x)
     f.write( EnharmonicNotes[x] + ' : ___ \hspace #3 ')
     g.write( EnharmonicNotes[x] + ' : \with-color #red \override #\'(font-name . "Linux Libertine Capitals") { { ' + EnharmonicNotesKey[x] + ' }} \hspace #3 ')
  f.write(' }}\n')
  g.write(' }}\n')

### Writing key signatures
##################################################
def WriteKeySigs(f,g):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Draw the following key signatures: }}\\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Draw the following key signatures: }}\\noPageBreak\n')
  f.write('{ \clef treble \\notimesig \\nobarline \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('{ \clef treble \\notimesig \\nobarline \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 1 \override TextScript #\'padding = #3 \\nokeycancel s1 ')
  temp = list(range(len(MajKeySigList)))
  temp.remove(7)
  randomlist = [ ]
  for i in range(6):
    x = random.choice(temp)
    temp.remove(x)
    randomlist.append(x)
  for i in randomlist:
    f.write(' s1^\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + MajKeySigList[i] + ' }} ')
    g.write(' s1 \\noBreak \override Score.RehearsalMark #\'break-align-symbols = #\'(key-signature) \override Staff.KeySignature #\'color = #red \override Staff.KeyCancellation #\'break-visibility = #\'#(#f #f #f) \key ' + MajKeySigListKey[i] + ' \major \mark \markup { \override #\'(font-name . "Linux Libertine Capitals") { ' + MajKeySigList[i] + ' }} ')
  f.write(' }\\noPageBreak\n')
  g.write(' }\\noPageBreak\n')
  f.write('{ \clef alto \\notimesig \\nobarline s1 }\\noPageBreak\n')
  g.write('{ \clef alto \\notimesig \\nobarline \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 1 \override TextScript #\'padding = #3 \\nokeycancel s1 ')
  for i in randomlist:
     g.write(' s1 \\noBreak \override Staff.KeySignature #\'color = #red \override Staff.KeyCancellation #\'break-visibility = #\'#(#f #f #f) \key ' + MajKeySigListKey[i] + ' \major ')
  g.write(' }\\noPageBreak\n')
  f.write('{ \clef tenor \\notimesig \\nobarline s1 }\\noPageBreak\n')
  g.write('{ \clef tenor \\notimesig \\nobarline \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 1 \override TextScript #\'padding = #3 \\nokeycancel s1 ')
  for i in randomlist:
    g.write(' s1 \\noBreak \override Staff.KeySignature #\'color = #red \override Staff.KeyCancellation #\'break-visibility = #\'#(#f #f #f) \key ' + MajKeySigListKey[i] + ' \major ')
  g.write(' }\\noPageBreak\n')
  f.write('{ \clef bass \\notimesig \\nobarline s1 }\\noPageBreak\n')
  g.write('{ \clef bass \\notimesig \\nobarline \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 1 \override TextScript #\'padding = #3 \\nokeycancel s1 ')
  for i in randomlist:
    g.write(' s1 \\noBreak \override Staff.KeySignature #\'color = #red \override Staff.KeyCancellation #\'break-visibility = #\'#(#f #f #f) \key ' + MajKeySigListKey[i] + ' \major ')
  g.write(' }\\noPageBreak\n')

### Identify scale degrees
##################################################
def IdentifyScaleDegrees(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") {Fill in the blanks: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") {Fill in the blanks: }} \\noPageBreak\n')
  f.write('\markup { }\n')
  g.write('\markup { }\n')
  degreelist = list(range(len(ScaleDegreeList)))
  keylist = list(MajKeySigList)
  for i in range(howmanytimes):
    if not degreelist:
      degreelist = list(range(len(ScaleDegreeList)))
    if not keylist:
      keylist = list(MajKeySigList)
    degree = random.choice(degreelist)
    key = random.choice(keylist)
    degreelist.remove(degree)
    keylist.remove(key)
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { The ' + ScaleDegreeList[degree] + ' of ' + key + ' Major is: ___ }}\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { The ' + ScaleDegreeList[degree] + ' of ' + key + ' Major is: \with-color #red { ' + ScaleDegreeDictKey[key][degree]  + ' } }} ')

### Relative keys
##################################################
def WriteRelativeMinorKeys(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the relative minor keys of the following major keys: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the relative minor keys of the following major keys: }} \\noPageBreak\n')
  f.write('\markup { }\n')
  g.write('\markup { }\n')
  temp = list(range(len(MajKeySigList)))
  for i in range(howmanytimes):
    if not temp:
      break
    x = random.choice(temp)
    temp.remove(x)
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { ' + MajKeySigList[x] + ' = ___ }}\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { ' + MajKeySigList[x] + ' = \with-color #red { ' + MinKeySigList[x] + ' } }}\n')

def WriteRelativeMajorKeys(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the relative major keys of the following minor keys: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the relative major keys of the following minor keys: }} \\noPageBreak\n')
  f.write('\markup { }\n')
  g.write('\markup { }\n')
  temp = list(range(len(MinKeySigList)))
  for i in range(howmanytimes):
    if not temp:
      break
    x = random.choice(temp)
    temp.remove(x)
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { ' + MinKeySigList[x] + ' = ___ }}\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { ' + MinKeySigList[x] + ' = \with-color #red { ' + MajKeySigList[x] + ' } }}\n')

### Writing scales
##################################################
def WriteAMajorScale(f,g):
  temp = list(range(len(WrittenMajorStartingNotes)))
  x = random.choice(temp)
  identclef = random.choice(clefs)
  octave = "f'" if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + WrittenMajorStartingNotes[x] + ' Major Scale ')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + WrittenMajorStartingNotes[x] + ' Major Scale ')
  if random.randrange(6) < 5:
    f.write('(with a key signature). }} \\noPageBreak ')
    g.write('(with a key signature). }} \\noPageBreak ')
    g.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig \override Staff.KeySignature #\'color = #red \key ' + MajKeySigListKey[x] + ' \major \override NoteHead #\'color = #red ' + IdentifyMajorScales[x] + ' }\n')
  else:
    f.write('(without a key signature). }} \\noPageBreak ')
    g.write('(without a key signature). }} \\noPageBreak ')
    g.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig \override NoteHead #\'color = #red \override Accidental #\'color = #red ' + IdentifyMajorScales[x] + ' }\n')
  f.write(' \\noPageBreak \n')
  g.write(' \\noPageBreak \n')
  f.write('{ \\nobarline \clef ' + identclef + ' \\notimesig s1 }\n')

def WriteAMinorScale(f,g):
  wmsnlist = list(range(len(WrittenMinorStartingNotes)))
  wmsn = random.choice(wmsnlist)
  mslist = list(range(len(MinorScales)))
  ms = random.choice(mslist)
  identclef = random.choice(clefs)
  octave = "f'" if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + WrittenMinorStartingNotes[wmsn] + ' ' + MinorScales[ms] + ' Scale ')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + WrittenMinorStartingNotes[wmsn] + ' ' + MinorScales[ms] + ' Scale ')
  if random.randrange(6) < 5:
    f.write('(with a key signature). }} \\noPageBreak ')
    g.write('(with a key signature). }} \\noPageBreak ')
    g.write('\\relative ' + octave + '{ \\nobarline \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \\time 4/4 \clef ' + identclef + ' \\notimesig \override Staff.KeySignature #\'color = #red \key ' + MinKeySigListKey[wmsn] + ' \minor \override NoteHead #\'color = #red \override Accidental #\'color = #red ' + MinorScalesKey[(wmsn*3)+ms] + ' }\n')
  else:
    f.write('(without a key signature). }} \\noPageBreak ')
    g.write('(without a key signature). }} \\noPageBreak ')
    g.write('\\relative ' + octave + '{ \\nobarline \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \\time 4/4 \clef ' + identclef + ' \\notimesig \override NoteHead #\'color = #red \override Accidental #\'color = #red ' + MinorScalesKey[(wmsn*3)+ms] + ' }\n')
  f.write(' \\noPageBreak \n')
  g.write(' \\noPageBreak \n')
  f.write('{ \\nobarline \clef ' + identclef + ' \\notimesig s1 }\n')

def WriteAChrOctWTScale(f,g):
  scalelist = list(range(len(ChrOctWTScales)))
  scale = random.choice(scalelist)
  chromaticStartList = list(range(len(ChromaticWrittenStartingNotes)))
  sn = random.choice(chromaticStartList)
  stwt = random.choice(list(range(len(OctatonicChoice))))
  identclef = random.choice(clefs)
  octave = "f'" if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
  if scale == 0: # chromatic scales
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + ChromaticWrittenStartingNotes[sn] + ' ' + ChrOctWTScales[scale] + ' Scale. }} \\noPageBreak \n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + ChromaticWrittenStartingNotes[sn] + ' ' + ChrOctWTScales[scale] + ' Scale. }} \\noPageBreak \n')
    g.write('\\relative ' + octave + '{ \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \\time 4/4 \cadenzaOn \\accidentalStyle #\'Score "forget" \clef ' + identclef + ' \\notimesig \override NoteHead #\'color = #red \override Accidental #\'color = #red \override Score.BarLine #\'color = #red ' + ChromaticScalesKey[sn]  + ' }\n')
  elif scale == 1: # wholetone scales
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + ChromaticWrittenStartingNotes[sn] + ' ' + ChrOctWTScales[scale] + ' Scale. }} \\noPageBreak \n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + ChromaticWrittenStartingNotes[sn] + ' ' + ChrOctWTScales[scale] + ' Scale. }} \\noPageBreak \n')
    g.write('\\relative ' + octave + '{ \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \\time 4/4 \cadenzaOn \clef ' + identclef + ' \\notimesig \override NoteHead #\'color = #red \override Accidental #\'color = #red ' + IdentifyWholetoneScales[sn]  + ' }\n')
  else: # octatonic scales
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + ChromaticWrittenStartingNotes[sn] + ' ' + ChrOctWTScales[scale] + ' Scale. (' + OctatonicChoice[stwt] + ') }} \\noPageBreak \n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + ChromaticWrittenStartingNotes[sn] + ' ' + ChrOctWTScales[scale] + ' Scale. (' + OctatonicChoice[stwt] + ') }} \\noPageBreak \n')
    g.write('\\relative ' + octave + '{ \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \\time 4/4 \cadenzaOn \clef ' + identclef + ' \\notimesig \override NoteHead #\'color = #red \override Accidental #\'color = #red ' + IdentifyOctatonicScales[(sn*2)+stwt]  + ' }\n')
  f.write('{ \\nobarline \clef ' + identclef + ' \\notimesig s1 }\n')

def WriteAMajorPentScale(f,g):
  wmsn = random.choice(list(range(len(WrittenMajorStartingNotes))))
  identclef = random.choice(clefs)
  octave = "f'" if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + WrittenMajorStartingNotes[wmsn] + ' Major Pentatonic Scale. }} \\noPageBreak \n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + WrittenMajorStartingNotes[wmsn] + ' Major Pentatonic Scale. }} \\noPageBreak \n')
  f.write('{ \\nobarline \clef ' + identclef + ' \\notimesig s1 }\n')
  g.write('\\relative ' + octave + '{ \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \\time 4/4 \cadenzaOn \clef ' + identclef + ' \override Staff.KeySignature #\'color = #red \key ' + MajKeySigListKey[wmsn] + ' \major \\notimesig \override NoteHead #\'color = #red \override Accidental #\'color = #red ' + IdentifyMajorPentScales[wmsn] + ' }\n')

def WriteAMinorPentScale(f,g):
  wmsn = random.choice(list(range(len(WrittenMinorStartingNotes))))
  identclef = random.choice(clefs)
  octave = "f'" if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + WrittenMinorStartingNotes[wmsn] + ' Minor Pentatonic Scale. }} \\noPageBreak \n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + WrittenMinorStartingNotes[wmsn] + ' Minor Pentatonic Scale. }} \\noPageBreak \n')
  f.write('{ \\nobarline \clef ' + identclef + ' \\notimesig s1 }\n')
  g.write('\\relative ' + octave + '{ \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \\time 4/4 \cadenzaOn \clef ' + identclef + ' \override Staff.KeySignature #\'color = #red \key ' + MinKeySigListKey[wmsn] + ' \minor \\notimesig \override NoteHead #\'color = #red \override Accidental #\'color = #red ' + IdentifyMinorPentScales[wmsn*3] + ' }\n')

def WriteABluesScale(f,g):
  wmsn = random.choice(list(range(len(WrittenMinorStartingNotes))))
  identclef = random.choice(clefs)
  octave = "f'" if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + WrittenMinorStartingNotes[wmsn] + ' Blues Scale. }} \\noPageBreak \n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + WrittenMinorStartingNotes[wmsn] + ' Blues Scale. }} \\noPageBreak \n')
  f.write('{ \\nobarline \clef ' + identclef + ' \\notimesig s1 }\n')
  g.write('\\relative ' + octave + '{ \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \\time 4/4 \cadenzaOn \clef ' + identclef + ' \override Staff.KeySignature #\'color = #red \key ' + MinKeySigListKey[wmsn] + ' \minor \\notimesig \override NoteHead #\'color = #red \override Accidental #\'color = #red ' + IdentifyBluesScales[wmsn*3] + ' }\n')

def WriteAModeScale(f,g):
  ms = random.choice(list(range(len(ModesScales))))
  identclef = random.choice(clefs)
  octave = "f'" if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + ModesScales[ms] + '. }} \\noPageBreak \n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write ' + ModesScales[ms] + '. }} \\noPageBreak \n')
  f.write('{ \\nobarline \clef ' + identclef + ' \\notimesig s1 }\n')
  g.write('\\relative ' + octave + '{ \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \\time 4/4 \cadenzaOn \clef ' + identclef + ' \override Staff.KeySignature #\'color = #red \key ' + FindModeKeySig(ms) + ' \major \\notimesig \override NoteHead #\'color = #red \override Accidental #\'color = #red ' + IdentifyModeScales[ms]  + ' }\n')

### Indentifying scales
def FindMajorKeySig(scalenumber):
  if scalenumber == 0:
    return 'ces'
  elif scalenumber == 1:
    return 'ges'
  elif scalenumber == 2:
    return 'des'
  elif scalenumber == 3:
    return 'aes'
  elif scalenumber == 4:
    return 'es'
  elif scalenumber == 5:
    return 'bes'
  elif scalenumber == 6:
    return 'f'
  elif scalenumber == 7:
    return 'c'
  elif scalenumber == 8:
    return 'g'
  elif scalenumber == 9:
    return 'd'
  elif scalenumber == 10:
    return 'a'
  elif scalenumber == 11:
    return 'e'
  elif scalenumber == 12:
    return 'b'
  elif scalenumber == 13:
    return 'fis'
  elif scalenumber == 14:
    return 'cis'

def FindMinorKeySig(scalenumber):
  if scalenumber in range(0,3):
    return 'aes'
  elif scalenumber in range(3,6):
    return 'es'
  elif scalenumber in range(6,9):
    return 'bes'
  elif scalenumber in range(9,12):
    return 'f'
  elif scalenumber in range(12,15):
    return 'c'
  elif scalenumber in range(15,18):
    return 'g'
  elif scalenumber in range(18,21):
    return 'd'
  elif scalenumber in range(21,24):
    return 'a'
  elif scalenumber in range(24,27):
    return 'e'
  elif scalenumber in range(27,30):
    return 'b'
  elif scalenumber in range(30,33):
    return 'fis'
  elif scalenumber in range(33,36):
    return 'cis'
  elif scalenumber in range(36,39):
    return 'gis'
  elif scalenumber in range(39,42):
    return 'dis'
  elif scalenumber in range(42,45):
    return 'ais'

def IdentifyAMajorScale(f,g):
  temp = list(range(len(WrittenMajorStartingNotes)))
  x = random.choice(temp)
  identclef = random.choice(clefs)
  octave = "f'" if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale:______________________ }} \\noPageBreak \n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale: \with-color #red { ' + WrittenMajorStartingNotes[x]  + ' Major Scale } }} \\noPageBreak \n')
  if random.randrange(6) < 5:
      f.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \key ' + FindMajorKeySig(x) + ' \major \\notimesig ' + IdentifyMajorScales[x]  + ' }\n')
      g.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \key ' + FindMajorKeySig(x) + ' \major \\notimesig ' + IdentifyMajorScales[x]  + ' }\n')
  else:
    f.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyMajorScales[x]  + ' }\n')
    g.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyMajorScales[x]  + ' }\n')

def IdentifyAMinorScale(f,g):
  wmsnlist = list(range(len(WrittenMinorStartingNotes)))
  wmsn = random.choice(wmsnlist)
  mslist = list(range(len(MinorScales)))
  ms = random.choice(mslist)
  identclef = random.choice(clefs)
  octave = "f'" if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale:______________________ }} \\noPageBreak \n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale: \with-color #red { ' + WrittenMinorStartingNotes[wmsn] + ' ' + MinorScales[ms] + ' Scale } }} \\noPageBreak \n')
  if random.randrange(6) < 5:
    f.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \key ' + FindMinorKeySig((wmsn*3)+ms) + ' \minor \\notimesig ' + IdentifyMinorScales[(wmsn*3)+ms]  + ' }\n')
    g.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \key ' + FindMinorKeySig((wmsn*3)+ms) + ' \minor \\notimesig ' + IdentifyMinorScales[(wmsn*3)+ms]  + ' }\n')
  else:
    f.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyMinorScales[(wmsn*3)+ms]  + ' }\n')
    g.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyMinorScales[(wmsn*3)+ms]  + ' }\n')

def IdentifyAChromaticScale(f,g):
  temp = list(range(len(IdentifyChromaticScales)))
  x = random.choice(temp)
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale:______________________. }} \\noPageBreak \n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale: \with-color #red { ' + ChromaticWrittenStartingNotes[x] + ' Chromatic } }} \\noPageBreak \n')
  f.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyChromaticScales[x] + ' }\n')
  g.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyChromaticScales[x] + ' }\n')

def IdentifyAWholetoneScale(f,g):
  temp = list(range(len(IdentifyWholetoneScales)))
  x = random.choice(temp)
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale:______________________. }} \\noPageBreak \n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale: \with-color #red { ' + ChromaticWrittenStartingNotes[x] + ' Wholetone } }} \\noPageBreak \n')
  f.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyWholetoneScales[x] + ' }\n')
  g.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyWholetoneScales[x] + ' }\n')

def IdentifyAOctatonicScale(f,g):
  temp = list(range(len(IdentifyOctatonicScales)))
  x = random.choice(temp)
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale:______________________. }} \\noPageBreak \n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale: \with-color #red { ' + IdentifyOctatonicScalesKey[x] + ' } }} \\noPageBreak \n')
  f.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyOctatonicScales[x] + ' }\n')
  g.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyOctatonicScales[x] + ' }\n')

def IdentifyAMajorPentScale(f,g):
  temp = list(range(len(IdentifyMajorPentScales)))
  x = random.choice(temp)
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale:______________________. }} \\noPageBreak \n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale:  \with-color #red { ' + MajorPentScaleWrittenStartingNotes[x] + ' Major Pentatonic } }} \\noPageBreak \n')
  if random.randrange(6) < 5:
      f.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \key ' + FindMajorKeySig(x) + ' \major \\notimesig ' + IdentifyMajorPentScales[x]  + ' }\n')
      g.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \key ' + FindMajorKeySig(x) + ' \major \\notimesig ' + IdentifyMajorPentScales[x]  + ' }\n')
  else:
    f.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyMajorPentScales[x]  + ' }\n')
    g.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyMajorPentScales[x]  + ' }\n')

def IdentifyAMinorPentScale(f,g):
  temp = list(range(len(IdentifyMinorPentScales)))
  x = random.choice(temp)
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale:______________________. }} \\noPageBreak \n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale:  \with-color #red { ' + MinorPentScaleWrittenStartingNotes[x] + ' Minor Pentatonic } }} \\noPageBreak \n')
  if random.randrange(6) < 5:
    f.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \key ' + FindMinorKeySig(x*3) + ' \minor \\notimesig ' + IdentifyMinorPentScales[x*3]  + ' }\n')
    g.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \key ' + FindMinorKeySig(x*3) + ' \minor \\notimesig ' + IdentifyMinorPentScales[x*3]  + ' }\n')
  else:
    f.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyMinorPentScales[x*3]  + ' }\n')
    g.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyMinorPentScales[x*3]  + ' }\n')

def IdentifyABluesScale(f,g):
  temp = list(range(len(IdentifyBluesScales)))
  x = random.choice(temp)
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale:______________________. }} \\noPageBreak \n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale: \with-color #red { ' + BluesScaleWrittenStartingNotes[x] + ' Blues } }} \\noPageBreak \n')
  if random.randrange(6) < 5:
    f.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \key ' + FindMinorKeySig(x*3) + ' \minor \\notimesig ' + IdentifyBluesScales[x*3]  + ' }\n')
    g.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \key ' + FindMinorKeySig(x*3) + ' \minor \\notimesig ' + IdentifyBluesScales[x*3]  + ' }\n')
  else:
    f.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyBluesScales[x*3]  + ' }\n')
    g.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyBluesScales[x*3]  + ' }\n')

def FindModeKeySig(scalenumber):
  if scalenumber in range(0,7):
    return 'c'
  elif scalenumber in range(7,14):
    return 'g'
  elif scalenumber in range(14,21):
    return 'd'
  elif scalenumber in range(21,28):
    return 'a'
  elif scalenumber in range(28,35):
    return 'e'
  elif scalenumber in range(35,42):
    return 'b'
  elif scalenumber in range(42,49):
    return 'fis'
  elif scalenumber in range(49,56):
    return 'cis'
  elif scalenumber in range(56,63):
    return 'f'
  elif scalenumber in range(63,70):
    return 'bes'
  elif scalenumber in range(70,77):
    return 'es'
  elif scalenumber in range(77,84):
    return 'aes'
  elif scalenumber in range(84,91):
    return 'des'
  elif scalenumber in range(91,98):
    return 'ges'
  elif scalenumber in range(98,105):
    return 'ces'

def IdentifyAModeScale(f,g):
  temp = list(range(len(IdentifyModeScales)))
  x = random.choice(temp)
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale:______________________. }} \\noPageBreak \n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following scale: \with-color #red { ' + ModesScales[x] + ' } }} \\noPageBreak \n')
  if random.randrange(6) < 5:
      f.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \key ' + FindModeKeySig(x) + ' \major \\notimesig ' + IdentifyModeScales[x]  + ' }\n')
      g.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \key ' + FindModeKeySig(x) + ' \major \\notimesig ' + IdentifyModeScales[x]  + ' }\n')
  else:
    f.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyModeScales[x]  + ' }\n')
    g.write('\\relative ' + octave + '{ \\nobarline \clef ' + identclef + ' \\notimesig ' + IdentifyModeScales[x]  + ' }\n')

### Intervals
##################################################
def IdentifyEasySimpleIntervals(f,g,howmanytimes):
  keyssel = list(range(len(IntervalsEasySimpleTransposeList)))
  keyslist = [ ]
  for i in range(howmanytimes):
    if not keyssel:
      keyssel = list(range(len(IntervalsEasySimpleTransposeList)))
    x = random.choice(keyssel)
    keyssel.remove(x)
    keyslist.append(x)
  intsel = list(range(len(IntervalsNameList)))
  intlist = [ ]
  for i in range(howmanytimes):
    if not intsel:
      intsel = list(range(len(IntervalsNameList)))
    x = random.choice(intsel)
    intsel.remove(x)
    intlist.append(x)
  identclef = random.choice(clefs)
  octave = ' ' if identclef == 'treble' else ',' if identclef == 'alto' else ',' if identclef == 'tenor' else ',,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following intervals, invert them and name the inversions: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following intervals, invert them and name the inversions: }} \\noPageBreak\n')
  f.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      f.write('\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { c\'1 \\bar \"\" \\noBreak ' + IntervalsTopNotesList[intlist[i]] + '! } ')
      g.write('\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { c\'1_\markup{ \with-color #red \override #\'(font-name . "Linux Libertine Capitals") { { ' + IntervalsNameList[intlist[i]] + ' } }} \\bar \"\" \\noBreak ' + IntervalsTopNotesList[intlist[i]] + '! } ')
    else:
      f.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { <c\' ' + IntervalsTopNotesList[intlist[i]] + '>1 } ')
      g.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { <c\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsNameList[intlist[i]] + ' } } }} ')
  f.write(' } \n' )
  g.write(' } \n' )
  f.write('{  \clef ' + identclef + ' \\notimesig s1 }\n')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      g.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' } } }} ')
    elif IntervalsNameList[intlist[i]] == 'A8':
      g.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ', { <c\'\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' } } }} ')
    elif IntervalsNameList[intlist[i]] == 'd8':
      g.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { c\'\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } \\bar \"\" \\noBreak ' + IntervalsTopNotesList[intlist[i]] + '! } ')
    else:
      g.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' } } }} ')
  g.write(' } \n' )

def WriteEasySimpleIntervalsAbove(f,g,howmanytimes):
  keyssel = list(range(len(IntervalsEasySimpleTransposeList)))
  keyslist = [ ]
  for i in range(howmanytimes):
    if not keyssel:
      keyssel = list(range(len(IntervalsEasySimpleTransposeList)))
    x = random.choice(keyssel)
    keyssel.remove(x)
    keyslist.append(x)
  intsel = list(range(len(IntervalsNameList)))
  intsel.remove(0)
  intlist = [ ]
  for i in range(howmanytimes):
    if not intsel:
      intsel = list(range(len(IntervalsNameList)))
      intsel.remove(0)
    x = random.choice(intsel)
    intsel.remove(x)
    intlist.append(x)
  identclef = random.choice(clefs)
  octave = ' ' if identclef == 'treble' else ',' if identclef == 'alto' else ',' if identclef == 'tenor' else ',,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write the following intervals above the given notes, invert them and name the inversions: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write the following intervals above the given notes, invert them and name the inversions: }} \\noPageBreak\n')
  f.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      f.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { c\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} } ')
      g.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { \override TextScript #\'padding = #3 c\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} \\bar \"\" \\noBreak \override NoteHead #\'color = #red \override Accidental #\'color = #red ' + IntervalsTopNotesList[intlist[i]] + '! } ')
    else:
      f.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { c\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' } }} ')
      g.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { <<{ \override NoteHead #\'color = #red \override Accidental #\'color = #red ' + IntervalsTopNotesList[intlist[i]] + '1 } \\\\{ \override TextScript #\'padding = #3 c\'_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} }>> } ')
  f.write(' } \n' )
  g.write(' } \n' )
  f.write('{  \clef ' + identclef + ' \\notimesig s1 }\n')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      g.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
    elif IntervalsNameList[intlist[i]] == 'A8':
      g.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ', { <c\'\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
    elif IntervalsNameList[intlist[i]] == 'd8':
      g.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { c\'\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } \\bar \"\" \\noBreak ' + IntervalsTopNotesList[intlist[i]] + '! } ')
    else:
      g.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
  g.write(' } \n' )

def WriteEasySimpleIntervalsBelow(f,g,howmanytimes):
  keyssel = list(range(len(IntervalsEasySimpleTransposeList)))
  keyslist = [ ]
  for i in range(howmanytimes):
    if not keyssel:
      keyssel = list(range(len(IntervalsEasySimpleTransposeList)))
    x = random.choice(keyssel)
    keyssel.remove(x)
    keyslist.append(x)
  intsel = list(range(len(IntervalsNameList)))
  intsel.remove(0)
  intlist = [ ]
  for i in range(howmanytimes):
    if not intsel:
      intsel = list(range(len(IntervalsNameList)))
      intsel.remove(0)
    x = random.choice(intsel)
    intsel.remove(x)
    intlist.append(x)
  identclef = random.choice(clefs)
  octave = ' ' if identclef == 'treble' else ',' if identclef == 'alto' else ',' if identclef == 'tenor' else ',,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write the following intervals below the given notes, invert them and name the inversions: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write the following intervals below the given notes, invert them and name the inversions: }} \\noPageBreak\n')
  f.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      f.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { ' + IntervalsTopNotesList[intlist[i]] + '1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} } ')
      g.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { ' + IntervalsTopNotesList[intlist[i]] + '1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} \\bar \"\" \\noBreak \override NoteHead #\'color = #red \override Accidental #\'color = #red \override TextScript #\'padding = #3 c\'!1 } ')
    else:
      f.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { ' + IntervalsTopNotesList[intlist[i]] + '1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} } ')
      g.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { <<{ ' + IntervalsTopNotesList[intlist[i]] + '1 } \\\\{ \override NoteHead #\'color = #red \override Accidental #\'color = #red \override TextScript #\'padding = #3 c\'_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} }>> } ')
  f.write(' } \n' )
  g.write(' } \n' )
  f.write('{  \clef ' + identclef + ' \\notimesig s1 }\n')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      g.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
    elif IntervalsNameList[intlist[i]] == 'A8':
      g.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ', { <c\'\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
    elif IntervalsNameList[intlist[i]] == 'd8':
      g.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { c\'\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } \\bar \"\" \\noBreak ' + IntervalsTopNotesList[intlist[i]] + '! } ')
    else:
      g.write( '\\transpose ' + IntervalsEasySimpleTransposeList[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
  g.write(' } \n' )

def IdentifyHardSimpleIntervals(f,g,howmanytimes):
  keyssel = list(range(len(IntervalsHardSimpleTransposeList)))
  keyslist = [ ]
  for i in range(howmanytimes):
    if not keyssel:
      keyssel = list(range(len(IntervalsHardSimpleTransposeList)))
    x = random.choice(keyssel)
    keyssel.remove(x)
    keyslist.append(x)
  intsel = list(range(len(IntervalsNameList)))
  intsel.remove(6)
  intsel.remove(11)
  intlist = [ ]
  for i in range(howmanytimes):
    if not intsel:
      intsel = list(range(len(IntervalsNameList)))
      intsel.remove(6)
      intsel.remove(11)
    x = random.choice(intsel)
    intsel.remove(x)
    intlist.append(x)
  identclef = random.choice(clefs)
  octave = ' ' if identclef == 'treble' else ',' if identclef == 'alto' else ',' if identclef == 'tenor' else ',,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following intervals, invert them and name the inversions: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following intervals, invert them and name the inversions: }} \\noPageBreak\n')
  f.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      f.write('\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { c\'1 \\bar \"\" \\noBreak ' + IntervalsTopNotesList[intlist[i]] + '! } ')
      g.write('\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { c\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsNameList[intlist[i]] + ' }} } \\bar \"\" \\noBreak ' + IntervalsTopNotesList[intlist[i]] + '! } ')
    else:
      f.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { <c\' ' + IntervalsTopNotesList[intlist[i]] + '>1 } ')
      g.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { <c\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsNameList[intlist[i]] + ' }} } } ')
  f.write(' } \n' )
  g.write(' } \n' )
  f.write('{  \clef ' + identclef + ' \\notimesig s1 }\n')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      g.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
    elif IntervalsNameList[intlist[i]] == 'A8':
      g.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ', { <c\'\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
    elif IntervalsNameList[intlist[i]] == 'd8':
      g.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { c\'\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } \\bar \"\" \\noBreak ' + IntervalsTopNotesList[intlist[i]] + '! } ')
    else:
      g.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
  g.write(' } \n' )

def WriteHardSimpleIntervalsAbove(f,g,howmanytimes):
  keyssel = list(range(len(IntervalsHardSimpleTransposeList)))
  keyslist = [ ]
  for i in range(howmanytimes):
    if not keyssel:
      keyssel = list(range(len(IntervalsHardSimpleTransposeList)))
    x = random.choice(keyssel)
    keyssel.remove(x)
    keyslist.append(x)
  intsel = list(range(len(IntervalsNameList)))
  intsel.remove(0)
  intsel.remove(6)
  intsel.remove(11)
  intlist = [ ]
  for i in range(howmanytimes):
    if not intsel:
      intsel = list(range(len(IntervalsNameList)))
      intsel.remove(0)
      intsel.remove(6)
      intsel.remove(11)
    x = random.choice(intsel)
    intsel.remove(x)
    intlist.append(x)
  identclef = random.choice(clefs)
  octave = ' ' if identclef == 'treble' else ',' if identclef == 'alto' else ',' if identclef == 'tenor' else ',,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write the following intervals above the given notes, invert them and name the inversions: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write the following intervals above the given notes, invert them and name the inversions: }} \\noPageBreak\n')
  f.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      f.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { c\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} } ')
      g.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { \override TextScript #\'padding = #3 c\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} \\bar \"\" \\noBreak \override NoteHead #\'color = #red \override Accidental #\'color = #red ' + IntervalsTopNotesList[intlist[i]] + '! } ')
    else:
      f.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { c\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} } ')
      g.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { <<{ \override NoteHead #\'color = #red \override Accidental #\'color = #red ' + IntervalsTopNotesList[intlist[i]] + '1 } \\\\{ \override TextScript #\'padding = #3 c\'_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} }>> } ')
  f.write(' } \n' )
  g.write(' } \n' )
  f.write('{  \clef ' + identclef + ' \\notimesig s1 }\n')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      g.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
    elif IntervalsNameList[intlist[i]] == 'A8':
      g.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ', { <c\'\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
    elif IntervalsNameList[intlist[i]] == 'd8':
      g.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { c\'\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } \\bar \"\" \\noBreak ' + IntervalsTopNotesList[intlist[i]] + '! } ')
    else:
      g.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
  g.write(' } \n' )

def WriteHardSimpleIntervalsBelow(f,g,howmanytimes):
  keyssel = list(range(len(IntervalsHardSimpleTransposeList)))
  keyslist = [ ]
  for i in range(howmanytimes):
    if not keyssel:
      keyssel = list(range(len(IntervalsHardSimpleTransposeList)))
    x = random.choice(keyssel)
    keyssel.remove(x)
    keyslist.append(x)
  intsel = list(range(len(IntervalsNameList)))
  intsel.remove(0)
  intsel.remove(6)
  intsel.remove(11)
  intlist = [ ]
  for i in range(howmanytimes):
    if not intsel:
      intsel = list(range(len(IntervalsNameList)))
      intsel.remove(0)
      intsel.remove(6)
      intsel.remove(11)
    x = random.choice(intsel)
    intsel.remove(x)
    intlist.append(x)
  identclef = random.choice(clefs)
  octave = ' ' if identclef == 'treble' else ',' if identclef == 'alto' else ',' if identclef == 'tenor' else ',,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write the following intervals below the given notes, invert them and name the inversions: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write the following intervals below the given notes, invert them and name the inversions: }} \\noPageBreak\n')
  f.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      f.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { ' + IntervalsTopNotesList[intlist[i]] + '1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} } ')
      g.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { ' + IntervalsTopNotesList[intlist[i]] + '1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} \\bar \"\" \\noBreak \override NoteHead #\'color = #red \override Accidental #\'color = #red \override TextScript #\'padding = #3 c\'!1 } ')
    else:
      f.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { ' + IntervalsTopNotesList[intlist[i]] + '1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} } ')
      g.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { <<{ ' + IntervalsTopNotesList[intlist[i]] + '1 } \\\\{ \override NoteHead #\'color = #red \override Accidental #\'color = #red \override TextScript #\'padding = #3 c\'_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} }>> } ')
  f.write(' } \n' )
  g.write(' } \n' )
  f.write('{  \clef ' + identclef + ' \\notimesig s1 }\n')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      g.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
    elif IntervalsNameList[intlist[i]] == 'A8':
      g.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ', { <c\'\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
    elif IntervalsNameList[intlist[i]] == 'd8':
      g.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { c\'\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } \\bar \"\" \\noBreak ' + IntervalsTopNotesList[intlist[i]] + '! } ')
    else:
      g.write( '\\transpose ' + IntervalsHardSimpleTransposeList[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
  g.write(' } \n' )

def IdentifyAllSimpleIntervals(f,g,howmanytimes):
  temp = IntervalsEasySimpleTransposeList + IntervalsHardSimpleTransposeList
  keyssel = list(range(len(temp)))
  keyslist = [ ]
  for i in range(howmanytimes):
    if not keyssel:
      keyssel = list(range(len(temp)))
    x = random.choice(keyssel)
    keyssel.remove(x)
    keyslist.append(x)
  intsel = list(range(len(IntervalsNameList)))
  intsel.remove(6)
  intsel.remove(11)
  intlist = [ ]
  for i in range(howmanytimes):
    if not intsel:
      intsel = list(range(len(IntervalsNameList)))
      intsel.remove(6)
      intsel.remove(11)
    x = random.choice(intsel)
    intsel.remove(x)
    intlist.append(x)
  identclef = random.choice(clefs)
  octave = ' ' if identclef == 'treble' else ',' if identclef == 'alto' else ',' if identclef == 'tenor' else ',,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following intervals, invert them and name the inversions: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following intervals, invert them and name the inversions: }} \\noPageBreak\n')
  f.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      f.write('\\transpose ' + temp[keyslist[i]] + ' { c\'1 \\bar \"\" \\noBreak ' + IntervalsTopNotesList[intlist[i]] + '! } ')
      g.write('\\transpose ' + temp[keyslist[i]] + ' { c\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsNameList[intlist[i]] + ' }} } \\bar \"\" \\noBreak ' + IntervalsTopNotesList[intlist[i]] + '! } ')
    else:
      f.write( '\\transpose ' + temp[keyslist[i]] + ' { <c\' ' + IntervalsTopNotesList[intlist[i]] + '>1 } ')
      g.write( '\\transpose ' + temp[keyslist[i]] + ' { <c\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsNameList[intlist[i]] + ' }} } } ')
  f.write(' } \n' )
  g.write(' } \n' )
  f.write('{  \clef ' + identclef + ' \\notimesig s1 }\n')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      g.write( '\\transpose ' + temp[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
    elif IntervalsNameList[intlist[i]] == 'A8':
      g.write( '\\transpose ' + temp[keyslist[i]] + ', { <c\'\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
    elif IntervalsNameList[intlist[i]] == 'd8':
      g.write( '\\transpose ' + temp[keyslist[i]] + ' { c\'\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } \\bar \"\" \\noBreak ' + IntervalsTopNotesList[intlist[i]] + '! } ')
    else:
      g.write( '\\transpose ' + temp[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
  g.write(' } \n' )

def WriteAllSimpleIntervalsAbove(f,g,howmanytimes):
  temp = IntervalsEasySimpleTransposeList + IntervalsHardSimpleTransposeList
  keyssel = list(range(len(temp)))
  keyslist = [ ]
  for i in range(howmanytimes):
    if not keyssel:
      keyssel = list(range(len(temp)))
    x = random.choice(keyssel)
    keyssel.remove(x)
    keyslist.append(x)
  intsel = list(range(len(IntervalsNameList)))
  intsel.remove(0)
  intsel.remove(6)
  intsel.remove(11)
  intlist = [ ]
  for i in range(howmanytimes):
    if not intsel:
      intsel = list(range(len(IntervalsNameList)))
      intsel.remove(0)
      intsel.remove(6)
      intsel.remove(11)
    x = random.choice(intsel)
    intsel.remove(x)
    intlist.append(x)
  identclef = random.choice(clefs)
  octave = ' ' if identclef == 'treble' else ',' if identclef == 'alto' else ',' if identclef == 'tenor' else ',,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write the following intervals above the given notes, invert them and name the inversions: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write the following intervals above the given notes, invert them and name the inversions: }} \\noPageBreak\n')
  f.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      f.write( '\\transpose ' + temp[keyslist[i]] + ' { c\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} } ')
      g.write( '\\transpose ' + temp[keyslist[i]] + ' { \override TextScript #\'padding = #3 c\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} \\bar \"\" \\noBreak \override NoteHead #\'color = #red \override Accidental #\'color = #red ' + IntervalsTopNotesList[intlist[i]] + '! } ')
    else:
      f.write( '\\transpose ' + temp[keyslist[i]] + ' { c\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} } ')
      g.write( '\\transpose ' + temp[keyslist[i]] + ' { <<{ \override NoteHead #\'color = #red \override Accidental #\'color = #red ' + IntervalsTopNotesList[intlist[i]] + '1 } \\\\{ \override TextScript #\'padding = #3 c\'_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} }>> } ')
  f.write(' } \n' )
  g.write(' } \n' )
  f.write('{  \clef ' + identclef + ' \\notimesig s1 }\n')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      g.write( '\\transpose ' + temp[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
    elif IntervalsNameList[intlist[i]] == 'A8':
      g.write( '\\transpose ' + temp[keyslist[i]] + ', { <c\'\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
    elif IntervalsNameList[intlist[i]] == 'd8':
      g.write( '\\transpose ' + temp[keyslist[i]] + ' { c\'\'1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } \\bar \"\" \\noBreak ' + IntervalsTopNotesList[intlist[i]] + '! } ')
    else:
      g.write( '\\transpose ' + temp[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
  g.write(' } \n' )

def WriteAllSimpleIntervalsBelow(f,g,howmanytimes):
  temp = IntervalsEasySimpleTransposeList + IntervalsHardSimpleTransposeList
  keyssel = list(range(len(temp)))
  keyslist = [ ]
  for i in range(howmanytimes):
    if not keyssel:
      keyssel = list(range(len(temp)))
    x = random.choice(keyssel)
    keyssel.remove(x)
    keyslist.append(x)
  intsel = list(range(len(IntervalsNameList)))
  intsel.remove(0)
  intsel.remove(6)
  intsel.remove(11)
  intlist = [ ]
  for i in range(howmanytimes):
    if not intsel:
      intsel = list(range(len(IntervalsNameList)))
      intsel.remove(0)
      intsel.remove(6)
      intsel.remove(11)
    x = random.choice(intsel)
    intsel.remove(x)
    intlist.append(x)
  identclef = random.choice(clefs)
  octave = ' ' if identclef == 'treble' else ',' if identclef == 'alto' else ',' if identclef == 'tenor' else ',,'
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write the following intervals below the given notes, invert them and name the inversions: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write the following intervals below the given notes, invert them and name the inversions: }} \\noPageBreak\n')
  f.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      f.write( '\\transpose ' + temp[keyslist[i]] + ' { ' + IntervalsTopNotesList[intlist[i]] + '1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} } ')
      g.write( '\\transpose ' + temp[keyslist[i]] + ' { ' + IntervalsTopNotesList[intlist[i]] + '1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} \\bar \"\" \\noBreak \override NoteHead #\'color = #red \override Accidental #\'color = #red \override TextScript #\'padding = #3 c\'!1 } ')
    else:
      f.write( '\\transpose ' + temp[keyslist[i]] + ' { ' + IntervalsTopNotesList[intlist[i]] + '1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} } ')
      g.write( '\\transpose ' + temp[keyslist[i]] + ' { <<{ ' + IntervalsTopNotesList[intlist[i]] + '1 } \\\\{ \override NoteHead #\'color = #red \override Accidental #\'color = #red \override TextScript #\'padding = #3 c\'_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsNameList[intlist[i]] + ' }} }>> } ')
  f.write(' } \n' )
  g.write(' } \n' )
  f.write('{  \clef ' + identclef + ' \\notimesig s1 }\n')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  for i in range(howmanytimes):
    if IntervalsNameList[intlist[i]] == 'AP':
      g.write( '\\transpose ' + temp[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
    elif IntervalsNameList[intlist[i]] == 'A8':
      g.write( '\\transpose ' + temp[keyslist[i]] + ', { <c\'\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
    elif IntervalsNameList[intlist[i]] == 'd8':
      g.write( '\\transpose ' + temp[keyslist[i]] + ' { c\'\'1_\markup{ \with-color #red { \override #\'(font-name . "Linux Libertine Capitals") { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } \\bar \"\" \\noBreak ' + IntervalsTopNotesList[intlist[i]] + '! } ')
    else:
      g.write( '\\transpose ' + temp[keyslist[i]] + ' { <c\'\' ' + IntervalsTopNotesList[intlist[i]] + '>1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + IntervalsInvertedNameList[intlist[i]] + ' }} } } ')
  g.write(' } \n' )

def IdentifyIntervalsInScales(f,g,howmanytimes):
  interval = random.choice(list(range(len(IntervalsInScalesList))))
  question = random.choice(IntervalsInScalesQuestions)
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name all ' + question + ' scales in which the following interval naturally occurs }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name all ' + question + ' scales in which the following interval naturally occurs }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = ' ' if identclef == 'treble' else ',' if identclef == 'alto' else ',' if identclef == 'tenor' else ',,'
  f.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 ' + IntervalsInScalesList[interval] + ' } \n')
  g.write('\\transpose c c' + octave + '{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 ' + IntervalsInScalesList[interval] + ' } \n')
  g.write('\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + question + ': ' + IntervalsInScalesKeyDict[question][interval] + ' }} } ')

### Chords
##################################################
def IdentifyAllChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following chords (root, quality & if V7 give possible keys):  }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following chords (root, quality & if V7 give possible keys):  }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3  ')
  temp = IdentifyEasyRootMajChordsList + IdentifyHardRootMajChordsList + IdentifyEasyRootMinChordsList + IdentifyHardRootMinChordsList + IdentifyEasyRootDimChordsList + IdentifyHardRootDimChordsList + IdentifyEasyRootAugChordsList + IdentifyHardRootAugChordsList + IdentifyEasyRootDomSevChordsList + IdentifyHardRootDomSevChordsList
  key = IdentifyEasyRootMajChordsKeyList + IdentifyHardRootMajChordsKeyList + IdentifyEasyRootMinChordsKeyList + IdentifyHardRootMinChordsKeyList + IdentifyEasyRootDimChordsKeyList + IdentifyHardRootDimChordsKeyList + IdentifyEasyRootAugChordsKeyList + IdentifyHardRootAugChordsKeyList + IdentifyEasyRootDomSevChordsKeyList + IdentifyHardRootDomSevChordsKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { ' + temp[i] + ' } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align \with-color #red { ' + key[i] + ' }} } } ')
  f.write(' }')
  g.write(' }')

def WriteAllChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out the following chords: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out the following chords: }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  temp = IdentifyEasyRootMajChordsList + IdentifyHardRootMajChordsList + IdentifyEasyRootMinChordsList + IdentifyHardRootMinChordsList + IdentifyEasyRootDimChordsList + IdentifyHardRootDimChordsList + IdentifyEasyRootAugChordsList + IdentifyHardRootAugChordsList + IdentifyEasyRootDomSevChordsList + IdentifyHardRootDomSevChordsList
  key = IdentifyEasyRootMajChordsKeyList + IdentifyHardRootMajChordsKeyList + IdentifyEasyRootMinChordsKeyList + IdentifyHardRootMinChordsKeyList + IdentifyEasyRootDimChordsKeyList + IdentifyHardRootDimChordsKeyList + IdentifyEasyRootAugChordsKeyList + IdentifyHardRootAugChordsKeyList + IdentifyEasyRootDomSevChordsKeyList + IdentifyHardRootDomSevChordsKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { s1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") {  \center-align { ' + key[i] + ' } } } } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align { ' + key[i] + ' }} } } ')
  f.write(' }')
  g.write(' }')

def IdentifyInvAllChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following chords (root, quality, inversion & if V7 give possible keys):  }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following chords (root, quality, inversion & if V7 give possible keys):  }} \\noPageBreak\n')
  identclef = 'treble'
  #random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3  ')
  temp = IdentifyEasyRootMajChordsList + IdentifyHardRootMajChordsList + IdentifyEasyRootMinChordsList + IdentifyHardRootMinChordsList + IdentifyEasyRootDimChordsList + IdentifyHardRootDimChordsList + IdentifyEasyRootAugChordsList + IdentifyHardRootAugChordsList + IdentifyEasyRootDomSevChordsList + IdentifyHardRootDomSevChordsList + IdentifyInvMajChordsList + IdentifyInvMinChordsList + IdentifyInvDimChordsList + IdentifyInvAugChordsList + IdentifyInvDomSevChordsList
  key = IdentifyEasyRootMajChordsKeyList + IdentifyHardRootMajChordsKeyList + IdentifyEasyRootMinChordsKeyList + IdentifyHardRootMinChordsKeyList + IdentifyEasyRootDimChordsKeyList + IdentifyHardRootDimChordsKeyList + IdentifyEasyRootAugChordsKeyList + IdentifyHardRootAugChordsKeyList + IdentifyEasyRootDomSevChordsKeyList + IdentifyHardRootDomSevChordsKeyList + IdentifyInvMajChordsKeyList + IdentifyInvMinChordsKeyList + IdentifyInvDimChordsKeyList + IdentifyInvAugChordsKeyList + IdentifyInvDomSevChordsKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { ' + temp[i] + ' } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align \with-color #red { ' + key[i] + ' }} } } ')
  f.write(' }')
  g.write(' }')

def WriteInvAllChords(f,g,howmanytimes):
  f.write('\markup { Write out the following chords in the position/inversion specified: } \\noPageBreak\n')
  g.write('\markup { Write out the following chords in the position/inversion specified: } \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  temp = IdentifyEasyRootMajChordsList + IdentifyHardRootMajChordsList + IdentifyEasyRootMinChordsList + IdentifyHardRootMinChordsList + IdentifyEasyRootDimChordsList + IdentifyHardRootDimChordsList + IdentifyEasyRootAugChordsList + IdentifyHardRootAugChordsList + IdentifyEasyRootDomSevChordsList + IdentifyHardRootDomSevChordsList + IdentifyInvMajChordsList + IdentifyInvMinChordsList + IdentifyInvDimChordsList + IdentifyInvAugChordsList + IdentifyInvDomSevChordsList
  key = IdentifyEasyRootMajChordsKeyList + IdentifyHardRootMajChordsKeyList + IdentifyEasyRootMinChordsKeyList + IdentifyHardRootMinChordsKeyList + IdentifyEasyRootDimChordsKeyList + IdentifyHardRootDimChordsKeyList + IdentifyEasyRootAugChordsKeyList + IdentifyHardRootAugChordsKeyList + IdentifyEasyRootDomSevChordsKeyList + IdentifyHardRootDomSevChordsKeyList + IdentifyInvMajChordsKeyList + IdentifyInvMinChordsKeyList + IdentifyInvDimChordsKeyList + IdentifyInvAugChordsKeyList + IdentifyInvDomSevChordsKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { s1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align { ' + key[i] + ' }} } } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align { ' + key[i] + ' }} } } ')
  f.write(' }')
  g.write(' }')

def IdentifyRootMajMinChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following Major/Minor triads (root & quality): }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following Major/Minor triads (root & quality): }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3  ')
  temp = IdentifyEasyRootMajChordsList + IdentifyHardRootMajChordsList + IdentifyEasyRootMinChordsList + IdentifyHardRootMinChordsList
  key = IdentifyEasyRootMajChordsKeyList + IdentifyHardRootMajChordsKeyList + IdentifyEasyRootMinChordsKeyList + IdentifyHardRootMinChordsKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { ' + temp[i] + ' } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align \with-color #red { ' + key[i] + ' }} } } ')
  f.write(' }')
  g.write(' }')

def WriteRootMajMinChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out the following triads: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out the following triads: }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \hideNotes ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  temp = IdentifyEasyRootMajChordsList + IdentifyHardRootMajChordsList + IdentifyEasyRootMinChordsList + IdentifyHardRootMinChordsList
  key = IdentifyEasyRootMajChordsKeyList + IdentifyHardRootMajChordsKeyList + IdentifyEasyRootMinChordsKeyList + IdentifyHardRootMinChordsKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align { ' + key[i] + ' }} } } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align { ' + key[i] + ' }} } } ')
  f.write(' }')
  g.write(' }')

def IdentifyInvMajMinChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following Major/Minor triads (root, quality & inversion): }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following Major/Minor triads (root, quality & inversion): }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  temp = IdentifyEasyRootMajChordsList + IdentifyHardRootMajChordsList + IdentifyEasyRootMinChordsList + IdentifyHardRootMinChordsList + IdentifyInvMajChordsList + IdentifyInvMinChordsList
  key = IdentifyEasyRootMajChordsKeyList + IdentifyHardRootMajChordsKeyList + IdentifyEasyRootMinChordsKeyList + IdentifyHardRootMinChordsKeyList + IdentifyInvMajChordsKeyList + IdentifyInvMinChordsKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { ' + temp[i] + ' } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align \with-color #red { ' + key[i] + ' }} } } ')
  f.write(' }')
  g.write(' }')

def WriteInvMajMinChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out the following triads in the position/inversion specified: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out the following triads in the position/inversion specified: }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \hideNotes ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  temp = IdentifyEasyRootMajChordsList + IdentifyHardRootMajChordsList + IdentifyEasyRootMinChordsList + IdentifyHardRootMinChordsList + IdentifyInvMajChordsList + IdentifyInvMinChordsList
  key = IdentifyEasyRootMajChordsKeyList + IdentifyHardRootMajChordsKeyList + IdentifyEasyRootMinChordsKeyList + IdentifyHardRootMinChordsKeyList + IdentifyInvMajChordsKeyList + IdentifyInvMinChordsKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align { ' + key[i] + ' }} } } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align { ' + key[i] + ' }} } } ')
  f.write(' }')
  g.write(' }')

def IdentifyRootDimAugChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following Diminished/Augmented triads (root & quality): }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following Diminished/Augmented triads (root & quality): }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  temp = IdentifyEasyRootDimChordsList + IdentifyHardRootDimChordsList + IdentifyEasyRootAugChordsList + IdentifyHardRootAugChordsList
  key = IdentifyEasyRootDimChordsKeyList + IdentifyHardRootDimChordsKeyList + IdentifyEasyRootAugChordsKeyList + IdentifyHardRootAugChordsKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { ' + temp[i] + ' } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align \with-color #red { ' + key[i] + ' }} } } ')
  f.write(' }')
  g.write(' }')

def WriteRootDimAugChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out the following triads: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out the following triads: }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \hideNotes ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  temp = IdentifyEasyRootDimChordsList + IdentifyHardRootDimChordsList + IdentifyEasyRootAugChordsList + IdentifyHardRootAugChordsList
  key = IdentifyEasyRootDimChordsKeyList + IdentifyHardRootDimChordsKeyList + IdentifyEasyRootAugChordsKeyList + IdentifyHardRootAugChordsKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align { ' + key[i] + ' }} } } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align { ' + key[i] + ' }} } } ')
  f.write(' }')
  g.write(' }')

def IdentifyInvDimAugChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following Diminished/Augmented triads (root, quality & inversion): }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following Diminished/Augmented triads (root, quality & inversion): }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  temp = IdentifyEasyRootDimChordsList + IdentifyHardRootDimChordsList + IdentifyEasyRootAugChordsList + IdentifyHardRootAugChordsList + IdentifyInvDimChordsList + IdentifyInvAugChordsList
  key = IdentifyEasyRootDimChordsKeyList + IdentifyHardRootDimChordsKeyList + IdentifyEasyRootAugChordsKeyList + IdentifyHardRootAugChordsKeyList + IdentifyInvDimChordsKeyList + IdentifyInvAugChordsKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { ' + temp[i] + ' } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align \with-color #red { ' + key[i] + ' }} } } ')
  f.write(' }')
  g.write(' }')

def WriteInvDimAugChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out the following triads in the position/inversion specified: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out the following triads in the position/inversion specified: }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = 'g\'' if identclef == 'treble' else 'a' if identclef == 'alto' else 'f' if identclef == 'tenor' else 'b,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \hideNotes ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  temp = IdentifyEasyRootDimChordsList + IdentifyHardRootDimChordsList + IdentifyEasyRootAugChordsList + IdentifyHardRootAugChordsList + IdentifyInvDimChordsList + IdentifyInvAugChordsList
  key = IdentifyEasyRootDimChordsKeyList + IdentifyHardRootDimChordsKeyList + IdentifyEasyRootAugChordsKeyList + IdentifyHardRootAugChordsKeyList + IdentifyInvDimChordsKeyList + IdentifyInvAugChordsKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align { ' + key[i] + ' }} } } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align { ' + key[i] + ' }} } } ')
  f.write(' }')
  g.write(' }')

def IdentifyRootDomSevChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following Dominant 7 chords (root & possible keys): }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following Dominant 7 chords (root & possible keys): }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = 'f\'' if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  temp = IdentifyEasyRootDomSevChordsList + IdentifyHardRootDomSevChordsList
  key = IdentifyEasyRootDomSevChordsKeyList + IdentifyHardRootDomSevChordsKeyList
  key2 = IdentifyEasyRootDomSevChordsKeysKeyList + IdentifyHardRootDomSevChordsKeysKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { ' + temp[i] + ' } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { \column { \line { ' + key[i] +  ' } ' + ' \line { ' + key2[i] + ' }} } } } } ')
  f.write(' }')
  g.write(' }')

def WriteRootDomSevChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out the following chords: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out the following chords: }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = 'f\'' if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \hideNotes ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  temp = IdentifyEasyRootDomSevChordsList + IdentifyHardRootDomSevChordsList
  key = IdentifyEasyRootDomSevChordsKeyList + IdentifyHardRootDomSevChordsKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align { ' + key[i] + ' }} } } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align { ' + key[i] + ' }} } } ')
  f.write(' }')
  g.write(' }')

def IdentifyInvDomSevChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following Dominant 7 chords (root, inversion & possible keys): }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following Dominant 7 chords (root, inversion & possible keys): }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = 'f\'' if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  temp = IdentifyEasyRootDomSevChordsList + IdentifyHardRootDomSevChordsList + IdentifyInvDomSevChordsList
  key = IdentifyEasyRootDomSevChordsInvKeyList + IdentifyHardRootDomSevChordsInvKeyList + IdentifyInvDomSevChordsKeyList
  key2 = IdentifyEasyRootDomSevChordsKeysKeyList + IdentifyHardRootDomSevChordsKeysKeyList + IdentifyInvDomSevChordsKeysKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { ' + temp[i] + ' } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { \column { \line { ' + key[i] +  ' } ' + ' \line { ' + key2[i] + ' }} } } } } ')
  f.write(' }')
  g.write(' }')

def WriteInvDomSevChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out the following chords in the position/inversion specified: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out the following chords in the position/inversion specified: }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = 'f\'' if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \hideNotes ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  temp = IdentifyEasyRootDomSevChordsList + IdentifyHardRootDomSevChordsList + IdentifyInvDomSevChordsList
  key = IdentifyEasyRootDomSevChordsInvKeyList + IdentifyHardRootDomSevChordsInvKeyList + IdentifyInvDomSevChordsKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align { ' + key[i] + ' }} } } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \center-align { ' + key[i] + ' }} } } ')
  f.write(' }')
  g.write(' }')

def WriteDomSevInversionsA(f,g):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out V7 chords, in all inversions, for the given keys: }}\\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out V7 chords, in all inversions, for the given keys: }}\\noPageBreak\n')
  temp = MajKeySigList + MinKeySigList
  key = IdentifyEasyRootDomSevChordsList + IdentifyHardRootDomSevChordsList + IdentifyInvDomSevChordsList
  x = list(range(len(temp)))
  x.remove(27)
  x.remove(28)
  x.remove(29)
  for i in range(4):
    identclef = random.choice(clefs)
    octave = 'f\'' if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
    f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 1 \override TextScript #\'padding = #3 \hideNotes ')
    g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
    z = random.choice(x)
    x.remove(z)
    f.write('\\relative ' + octave + ' { s1^\markup { \override #\'(font-name . "Linux Libertine Capitals") { ' + temp[z] + ' }} s s s }\n')
    g.write(' s1^\markup { \override #\'(font-name . "Linux Libertine Capitals") { ' + temp[z] + ' }} ')
    for a in WriteAllInvDomSevDict[z]:
      g.write('\\relative ' + octave + ' { ' + key[a] + ' } ')
    f.write(' }')
    g.write(' }')

def WriteDomSevInversionsB(f,g):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out V 7 chords, in all inversions, using the given note for the lowest of each chord: }}\\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out V 7 chords, in all inversions, using the given note for the lowest of each chord: }}\\noPageBreak\n')
  temp = WriteDomSevAllInv
  key = IdentifyEasyRootDomSevChordsList + IdentifyHardRootDomSevChordsList + IdentifyInvDomSevChordsList
  key2 = IdentifyEasyRootDomSevChordsInvKeyList + IdentifyHardRootDomSevChordsInvKeyList + IdentifyInvDomSevChordsKeyList
  x = random.choice(list(range(len(temp))))
  identclef = random.choice(clefs)
  octave = 'f\'' if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 1 \override TextScript #\'padding = #3 ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  f.write('\\relative ' + octave + ' { ')
  for i in range(4):
    f.write(temp[x] + ' ')
  f.write(' } } ')
  g.write('\\relative ' + octave + ' { ')
  for i in WriteDomSevAllInvDict[x]:
    g.write(key[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + key2[i] + ' }} } ')
  g.write(' } } ')

def IdentifyChordsInScales(f,g):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name all scales in which the following chord naturally occurs: }}\\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name all scales in which the following chord naturally occurs: }}\\noPageBreak\n')
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { (maj, min, har min, mel min) }}\\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { (maj, min, har min, mel min) }}\\noPageBreak\n')
  temp = IdentifyEasyRootMajChordsList + IdentifyHardRootMajChordsList + IdentifyEasyRootMinChordsList + IdentifyHardRootMinChordsList + IdentifyEasyRootDimChordsList + IdentifyHardRootDimChordsList + IdentifyEasyRootAugChordsList
  x = random.choice(list(range(len(temp))))
  identclef = random.choice(clefs)
  octave = 'f\'' if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 1 \override TextScript #\'padding = #3 \\relative ' + octave + ' { ' + temp[x] + ' } \stopStaff s s s }\n')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 1 \override TextScript #\'padding = #3 \\relative ' + octave + ' { ' + temp[x] + ' } \stopStaff s s s }\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { Major: ' + ChordsInScalesMaj[x] + ' } } } ')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { Natural Minor: ' + ChordsInScalesMin[x] + ' } } } ')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { Harmonic Minor: ' + ChordsInScalesHar[x] + ' } } } ')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { Melodic Minor: ' + ChordsInScalesMel[x] + ' } } } ')

def IdentifyOtherSevChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following Major7, Minor7, 1/2 Diminished & Fully Diminished Chords (root & quality): }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following Major7, Minor7, 1/2 Diminished & Fully Diminished Chords (root & quality): }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = 'f\'' if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  temp = IdentifyMajSevChordsList + IdentifyMinSevChordsList + IdentifyHalfDimChordsList + IdentifyFullDimChordsList
  key = IdentifyMajSevChordsKeyList + IdentifyMinSevChordsKeyList + IdentifyHalfDimChordsKeyList + IdentifyFullDimChordsKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { ' + temp[i] + ' } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { \with-color #red { ' + key[i] +  ' }} } } ')
  f.write(' }')
  g.write(' }')

def WriteOtherSevChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out the following 7th Chords: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write out the following 7th Chords: }} \\noPageBreak\n')
  identclef = random.choice(clefs)
  octave = 'f\'' if identclef == 'treble' else 'g' if identclef == 'alto' else 'e' if identclef == 'tenor' else 'a,'
  f.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('{ \clef ' + identclef + ' \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 \override NoteHead #\'color = #red \override Accidental #\'color = #red ')
  temp = IdentifyMajSevChordsList + IdentifyMinSevChordsList + IdentifyHalfDimChordsList + IdentifyFullDimChordsList
  key = IdentifyMajSevChordsKeyList + IdentifyMinSevChordsKeyList + IdentifyHalfDimChordsKeyList + IdentifyFullDimChordsKeyList
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  for i in y:
    f.write('\\relative ' + octave + ' { s1_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + key[i] + ' } } } ')
    g.write('\\relative ' + octave + ' { ' + temp[i] + '_\markup{ \override #\'(font-name . "Linux Libertine Capitals") { ' + key[i] +  ' } } } ')
  f.write(' }')
  g.write(' }')

def IdentifyOtherChords(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following extended chords (quality): }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Name the following extended chords (quality): }} \\noPageBreak\n')
  f.write('\\new PianoStaff <<\n')
  g.write('\\new PianoStaff <<\n')
  temp = IdentifyOtherChordsTreble
  key = IdentifyOtherChordsKey
  x = list(range(len(temp)))
  y = [ ]
  for i in range(howmanytimes):
    if not x:
      break
    z = random.choice(x)
    y.append(z)
    x.remove(z)
  f.write('\t\\new Staff { \clef treble \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('\t\\new Staff { \clef treble \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  for i in y:
    f.write(IdentifyOtherChordsTreble[i])
    g.write(IdentifyOtherChordsTreble[i])
  f.write(' }\n')
  g.write(' }\n')
  f.write('\t\\new Staff { \clef bass \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  g.write('\t\\new Staff { \clef bass \\notimesig \\nobarlinenumbers \override Score.SpacingSpanner #\'spacing-increment = 0 \override Score.SpacingSpanner #\'shortest-duration-space = 0 \override TextScript #\'padding = #3 ')
  for i in y:
    f.write(IdentifyOtherChordsBass[i])
    g.write(IdentifyOtherChordsBass[i] + '_\markup { \with-color #red { \override #\'(font-name . "Linux Libertine Capitals") { ' + IdentifyOtherChordsKey[i] + ' }}} ')
  f.write(' }\n >>')
  g.write(' }\n >>')

### Cadences
##################################################
def IdentifyCadences(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following cadences, provide the key and give the roman numerals for the chords: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Identify the following cadences, provide the key and give the roman numerals for the chords: }} \\noPageBreak\n')
  f.write('\\new PianoStaff <<\n')
  g.write('\\new PianoStaff <<\n')
  numbers = list(range(len(IdentifyCadencesTrebleFirst)))
  randomnumbers = [ ]
  for i in range(howmanytimes):
    if not numbers:
      break
    x = random.choice(numbers)
    randomnumbers.append(x)
    numbers.remove(x)
  keys = list(range(len(IdentifyCadencesTranspositions)))
  randomkeys = [ ]
  for i in range(howmanytimes):
    if not keys:
      break
    x = random.choice(keys)
    randomkeys.append(x)
    keys.remove(x)
  f.write('\t\\new Staff { \\nokeycancel \\nobarlinenumbers \clef treble \\notimesig ')
  g.write('\t\\new Staff { \\nokeycancel \\nobarlinenumbers \clef treble \\notimesig \override TextScript #\'padding = #3 ')
  q = 0
  for i in randomnumbers:
    f.write('\\transpose ' + IdentifyCadencesTranspositions[randomkeys[q]] + ' { ' + IdentifyCadencesTrebleFirst[i] + ' ' + IdentifyCadencesTrebleRest[i] + ' } \\bar "||" ')
    g.write('\\transpose ' + IdentifyCadencesTranspositions[randomkeys[q]] + ' { ' + IdentifyCadencesTrebleFirst[i] + '^\markup { \with-color #red { \override #\'(font-name . "Linux Libertine Capitals") { \center-column { \line {Key: ' + IdentifyCadencesTranspositionsKey[randomkeys[q]])
    if i in range(0,5):
      g.write(' Major} ')
    else:
      g.write(' Minor} ')
    g.write(' \line { ' + IdentifyCadencesTrebleKey[i] + '}}  }}} '  + IdentifyCadencesTrebleRest[i] + ' } \\bar "||" ')
    q = q + 1
  f.write(' }\n')
  g.write(' }\n')
  f.write('\t\\new Staff { \\nokeycancel \clef bass \\notimesig ')
  g.write('\t\\new Staff { \\nokeycancel \clef bass \\notimesig \override TextScript #\'padding = #3 ')
  q = 0
  for i in randomnumbers:
    f.write('\\transpose ' + IdentifyCadencesTranspositions[randomkeys[q]] + ' { ' + IdentifyCadencesBass[i] + ' } ')
    g.write('\\transpose ' + IdentifyCadencesTranspositions[randomkeys[q]] + ' { ' + IdentifyCadencesBassKey[i] + ' } ')
    q = q + 1
  f.write(' }\n')
  g.write(' }\n')
  f.write('>>\n')
  g.write('>>\n')

def WriteCadences(f,g,howmanytimes):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write the following cadences, keys and roman numerals: }} \\noPageBreak\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Write the following cadences, keys and roman numerals: }} \\noPageBreak\n')
  f.write('\\new PianoStaff <<\n')
  g.write('\\new PianoStaff <<\n')
  numbers = list(range(len(IdentifyCadencesTrebleFirst)))
  randomnumbers = [ ]
  for i in range(howmanytimes):
    if not numbers:
      break
    x = random.choice(numbers)
    randomnumbers.append(x)
    numbers.remove(x)
  keys = list(range(len(IdentifyCadencesTranspositions)))
  randomkeys = [ ]
  for i in range(howmanytimes):
    if not keys:
      break
    x = random.choice(keys)
    randomkeys.append(x)
    keys.remove(x)
  f.write('\t\\new Staff { \\nokeycancel \\nobarlinenumbers \clef treble \\notimesig \override TextScript #\'padding = #3 ')
  g.write('\t\\new Staff { \\nokeycancel \\nobarlinenumbers \clef treble \\notimesig \override TextScript #\'padding = #3 \override Staff.KeySignature #\'color = #red \override NoteHead #\'color = #red \override Accidental #\'color = #red \override Stem #\'color = #red ')
  q = 0
  for i in randomnumbers:
    f.write('\\transpose ' + IdentifyCadencesTranspositions[randomkeys[q]] + ' { s1^\markup { \override #\'(font-name . "Linux Libertine Capitals") { \center-column { \line {Key: ' + IdentifyCadencesTranspositionsKey[randomkeys[q]])
    g.write('\\transpose ' + IdentifyCadencesTranspositions[randomkeys[q]] + ' { ' + IdentifyCadencesTrebleFirst[i] + '^\markup { \override #\'(font-name . "Linux Libertine Capitals") { \center-column { \line {Key: ' + IdentifyCadencesTranspositionsKey[randomkeys[q]])
    if i in range(0,5):
      f.write(' Major} ')
      g.write(' Major} ')
    else:
      f.write(' Minor} ')
      g.write(' Minor} ')
    f.write(' \line { ' + IdentifyCadencesTrebleKey[i] + '}  }}} } s1  \\bar "||" ')
    g.write(' \line { ' + IdentifyCadencesTrebleKey[i] + '}  }}} '  + IdentifyCadencesTrebleRest[i] + ' } \\bar "||" ')
    q = q + 1
  f.write(' }\n')
  g.write(' }\n')
  f.write('\t\\new Staff { \\nokeycancel \clef bass \\notimesig ')
  g.write('\t\\new Staff { \\nokeycancel \clef bass \\notimesig \override TextScript #\'padding = #3 \override Staff.KeySignature #\'color = #red \override NoteHead #\'color = #red \override Accidental #\'color = #red \override Stem #\'color = #red ')
  q = 0
  for i in randomnumbers:
    f.write('\\transpose ' + IdentifyCadencesTranspositions[randomkeys[q]] + ' { s1 s } ')
    g.write('\\transpose ' + IdentifyCadencesTranspositions[randomkeys[q]] + ' { ' + IdentifyCadencesBassKey[i] + ' } ')
    q = q + 1
  f.write(' }\n')
  g.write(' }\n')
  f.write('>>\n')
  g.write('>>\n')

### Transposition
##################################################
def WrittenTransposition(f,g,examplenumber):
  identclef = random.choice(clefs)
  octave = 'b\'' if identclef == 'treble' else 'c\'' if identclef == 'alto' else 'a' if identclef == 'tenor' else 'd'
  x = random.choice(list(range(len(TranspositionIntervalsList))))
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Transpose the following example: } ' + TranspositionIntervalsList[x] + ' }\n')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Transpose the following example: } ' + TranspositionIntervalsList[x] + ' }\n')
  f.write('\\relative ' + octave + ' { \clef ' + identclef + ' \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 1 '  + TranspositionExamplesList[examplenumber] + '}\n' )
  g.write('\\relative ' + octave + ' { \clef ' + identclef + ' \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 1 '  + TranspositionExamplesList[examplenumber] + '}\n' )
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Original key : }}')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Original key : \with-color #red { ' + TranspositionExamplesKeysList[examplenumber] + ' }}} ')
  f.write('{ \clef ' + identclef + ' \\notimesig s1 } ')
  g.write('{ \override Staff.KeySignature #\'color = #red \override NoteHead #\'color = #red \override Accidental #\'color = #red \override Stem #\'color = #red \override Beam #\'color = #red \override Rest #\'color = #red \override Flag #\'color = #red \override Staff.LedgerLineSpanner #\'color = #red  \\transpose ' + TranspositionIntervalsListKey[x] + ' { \\relative ' + octave + ' { \clef ' + identclef + ' \override Score.SpacingSpanner #\'spacing-increment = 1 \override Score.SpacingSpanner #\'shortest-duration-space = 1 ' + TranspositionExamplesList[examplenumber] + '}}}\n')
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { New key : }}')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { New key : \with-color #red { ' + TranspositionExamplesNewKeysDict[examplenumber][x] + ' }}}')

### Time Signatures
##################################################
def TimeSignatures(f,g,examplenumber):
  f.write(TimeSigList[examplenumber])
  g.write(TimeSigKeyList[examplenumber])

### Detect Errors
##################################################
def DetectErrors(f,g,examplenumber):
  f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Circle all notation errors: }} ')
  g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals") { Circle all notation errors: }} ')
  f.write(DetectErrorsList[examplenumber])
  g.write(DetectErrorsKeyList[examplenumber])

### FOOTERS
##################################################
def moduleFooters(f,g):
    f.write('\markup { } \markup { }\n\n\n')
    g.write('\markup { } \markup { }\n\n\n')

def lilypondFooters(f,g):
    f.writelines(footer)
    g.writelines(footer)



##################################################
# MAIN FUNCTION
##################################################

def main():
  f = open(fillInSheet, 'w')
  g = open(keySheet, 'w')

  # start looking at command line arguments
  args = cliargs.parse_args()

  # write header
  lilypondHeaders(f,g,args.title,args.copyright)

  # All
  if args.all:
    args = cliargs.parse_args([ '--aural-intervals' , '--clefs' , '--notes' , '--durations' , '--cst-dst-wt' , '--circle-of-fifths' , '--key-sigs' , '--scale-degrees' , '--relative-keys' , '--all-scales' , '--all-simple-intervals' , '--intervals-in-scales' , '--all-chords-inv' , '--cadences' , '--transposition' , '--time-sigs' , '--detect-errors' ])

  # aural intervals
  if args.aural_intervals:
    AuralIntervals(f,g,args.aural_intervals)
    moduleFooters(f,g)

  # clefs
  if args.clefs:
    DrawClefs(f,g,args.clefs)
    moduleFooters(f,g)

  # note names
  if args.notes:
    WriteNotes(f,g,args.notes)
    moduleFooters(f,g)

    IdentifyNotes(f,g,args.notes)
    moduleFooters(f,g)

  # durations
  if args.durations:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Note & Rest Durations }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Note & Rest Durations }} \\noPageBreak\n')
    WriteASingleNoteEqualTo(f,g,args.durations)
    moduleFooters(f,g)

    WriteASingleRestEqualTo(f,g,args.durations)
    moduleFooters(f,g)

    WriteTwoNotesEqualTo(f,g,args.durations)
    moduleFooters(f,g)

    WriteTwoRestsEqualTo(f,g,args.durations)
    moduleFooters(f,g)

    WriteThreeNotesEqualTo(f,g,args.durations)
    moduleFooters(f,g)

    WriteThreeRestsEqualTo(f,g,args.durations)
    moduleFooters(f,g)

    CompareDurations(f,g,args.durations)
    moduleFooters(f,g)

  # cst dst wt
  if args.cst_dst_wt:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chromatic/Diatonic Semitones & Wholetones }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chromatic/Diatonic Semitones & Wholetones }} \\noPageBreak\n')

    IdentifyCstDstWt(f,g,args.cst_dst_wt)
    moduleFooters(f,g)

    WriteCstAbove(f,g,args.cst_dst_wt)
    moduleFooters(f,g)

    WriteDstAbove(f,g,args.cst_dst_wt)
    moduleFooters(f,g)

    WriteWtAbove(f,g,args.cst_dst_wt)
    moduleFooters(f,g)

    WriteCstBelow(f,g,args.cst_dst_wt)
    moduleFooters(f,g)

    WriteDstBelow(f,g,args.cst_dst_wt)
    moduleFooters(f,g)

    WriteWtBelow(f,g,args.cst_dst_wt)
    moduleFooters(f,g)

    WriteEnharmonic(f,g)
    moduleFooters(f,g)

  # circle of fifths
  if args.circle_of_fifths:
    f.writelines(CircleOfFifths)
    g.writelines(CircleOfFifthsKey)
    moduleFooters(f,g)

  # key sigs
  if args.key_sigs:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Key Signatures }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Key Signatures }} \\noPageBreak\n')
    WriteKeySigs(f,g)
    moduleFooters(f,g)

  # ident scale degrees
  if args.scale_degrees:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Scale Degrees }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Scale Degrees }} \\noPageBreak\n')
    IdentifyScaleDegrees(f,g,args.scale_degrees)
    moduleFooters(f,g)

  # relative keys
  if args.relative_keys:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Relative Keys }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Relative Keys }} \\noPageBreak\n')
    WriteRelativeMinorKeys(f,g,args.relative_keys)
    moduleFooters(f,g)

    WriteRelativeMajorKeys(f,g,args.relative_keys)
    moduleFooters(f,g)

  # scales
  if args.all_scales:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Scales }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Scales }} \\noPageBreak\n')
    for i in range(args.all_scales):
      scale = random.choice([WriteAMajorScale,IdentifyAMajorScale,WriteAMinorScale,IdentifyAMinorScale,WriteAChrOctWTScale,IdentifyAChromaticScale,IdentifyAOctatonicScale,IdentifyAWholetoneScale,WriteAMajorPentScale,WriteAMinorPentScale,WriteABluesScale,IdentifyAMajorPentScale,IdentifyAMinorPentScale,IdentifyABluesScale,WriteAModeScale,IdentifyAModeScale])
      scale(f,g)
    moduleFooters(f,g)

  if args.s_maj:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Major Scales }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Major Scales }} \\noPageBreak\n')
    for i in range(args.s_maj):
      scale = random.choice([WriteAMajorScale,IdentifyAMajorScale])
      scale(f,g)
    moduleFooters(f,g)

  if args.s_min:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Minor Scales }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Minor Scales }} \\noPageBreak\n')
    for i in range(args.s_min):
      scale = random.choice([WriteAMinorScale,IdentifyAMinorScale])
      scale(f,g)
    moduleFooters(f,g)

  if args.s_chroctwt:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chromatic, Octatonic & Wholetone Scales }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chromatic, Octatonic & Wholetone Scales }} \\noPageBreak\n')
    for i in range(args.s_chroctwt):
      scale = random.choice([WriteAChrOctWTScale,WriteAChrOctWTScale,WriteAChrOctWTScale,IdentifyAChromaticScale,IdentifyAOctatonicScale,IdentifyAWholetoneScale])
      scale(f,g)
    moduleFooters(f,g)

  if args.s_pentblues:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Pentatonic & Blues Scales }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Pentatonic & Blues Scales }} \\noPageBreak\n')
    for i in range(args.s_pentblues):
      scale = random.choice([WriteAMajorPentScale,WriteAMinorPentScale,WriteABluesScale,IdentifyAMajorPentScale,IdentifyAMinorPentScale,IdentifyABluesScale])
      scale(f,g)
    moduleFooters(f,g)

  if args.s_modes:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Modes }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Modes }} \\noPageBreak\n')
    for i in range(args.s_modes):
      scale = random.choice([WriteAModeScale,IdentifyAModeScale])
      scale(f,g)
    moduleFooters(f,g)

  # intervals
  if args.easy_simple_intervals:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Intervals }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Intervals }} \\noPageBreak\n')
    IdentifyEasySimpleIntervals(f,g,args.easy_simple_intervals)
    WriteEasySimpleIntervalsAbove(f,g,args.easy_simple_intervals)
    WriteEasySimpleIntervalsBelow(f,g,args.easy_simple_intervals)
    moduleFooters(f,g)

  if args.hard_simple_intervals:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Intervals }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Intervals }} \\noPageBreak\n')
    IdentifyHardSimpleIntervals(f,g,args.hard_simple_intervals)
    WriteHardSimpleIntervalsAbove(f,g,args.hard_simple_intervals)
    WriteHardSimpleIntervalsBelow(f,g,args.hard_simple_intervals)
    moduleFooters(f,g)

  if args.all_simple_intervals:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Intervals }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Intervals }} \\noPageBreak\n')
    IdentifyAllSimpleIntervals(f,g,args.all_simple_intervals)
    WriteAllSimpleIntervalsAbove(f,g,args.all_simple_intervals)
    WriteAllSimpleIntervalsBelow(f,g,args.all_simple_intervals)
    moduleFooters(f,g)

  if args.intervals_in_scales:
    IdentifyIntervalsInScales(f,g,args.intervals_in_scales)
    moduleFooters(f,g)

  # chords
  if args.all_chords:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chords }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chords }} \\noPageBreak\n')
    IdentifyAllChords(f,g,args.all_chords)
    WriteAllChords(f,g,args.all_chords)
    IdentifyOtherSevChords(f,g,args.all_chords)
    WriteOtherSevChords(f,g,args.all_chords)
    IdentifyOtherChords(f,g,args.all_chords)
    IdentifyChordsInScales(f,g)
    moduleFooters(f,g)

  if args.all_chords_inv:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chords }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chords }} \\noPageBreak\n')
    IdentifyInvAllChords(f,g,args.all_chords_inv)
    WriteInvAllChords(f,g,args.all_chords_inv)
    WriteDomSevInversionsA(f,g)
    WriteDomSevInversionsB(f,g)
    IdentifyOtherSevChords(f,g,args.all_chords_inv)
    WriteOtherSevChords(f,g,args.all_chords_inv)
    IdentifyOtherChords(f,g,args.all_chords_inv)
    IdentifyChordsInScales(f,g)
    moduleFooters(f,g)

  if args.c_maj_min:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chords }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chords }} \\noPageBreak\n')
    IdentifyRootMajMinChords(f,g,args.c_maj_min)
    WriteRootMajMinChords(f,g,args.c_maj_min)
    moduleFooters(f,g)

  if args.c_maj_min_inv:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chords }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chords }} \\noPageBreak\n')
    IdentifyInvMajMinChords(f,g,args.c_maj_min_inv)
    WriteInvMajMinChords(f,g,args.c_maj_min_inv)
    moduleFooters(f,g)

  if args.c_dim_aug:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chords }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chords }} \\noPageBreak\n')
    IdentifyRootDimAugChords(f,g,args.c_dim_aug)
    WriteRootDimAugChords(f,g,args.c_dim_aug)
    moduleFooters(f,g)

  if args.c_dim_aug_inv:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chords }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chords }} \\noPageBreak\n')
    IdentifyInvDimAugChords(f,g,args.c_dim_aug_inv)
    WriteInvDimAugChords(f,g,args.c_dim_aug_inv)
    moduleFooters(f,g)

  if args.c_dom7:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chords }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chords }} \\noPageBreak\n')
    IdentifyRootDomSevChords(f,g,args.c_dom7)
    WriteRootDomSevChords(f,g,args.c_dom7)
    moduleFooters(f,g)

  if args.c_dom7_inv:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chords }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Chords }} \\noPageBreak\n')
    IdentifyInvDomSevChords(f,g,args.c_dom7_inv)
    WriteInvDomSevChords(f,g,args.c_dom7_inv)
    WriteDomSevInversionsA(f,g)
    WriteDomSevInversionsB(f,g)
    moduleFooters(f,g)

  if args.c_other_7ths:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Other 7th Chords }} \\noPageBreak\n')
    IdentifyOtherSevChords(f,g,args.c_other_7ths)
    WriteOtherSevChords(f,g,args.c_other_7ths)
    moduleFooters(f,g)

  if args.c_ext_chords:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Extended Chords }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Extended Chords }} \\noPageBreak\n')
    IdentifyOtherChords(f,g,args.c_ext_chords)
    moduleFooters(f,g)

  # cadences
  if args.cadences:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Cadences }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Cadences }} \\noPageBreak\n')
    IdentifyCadences(f,g,args.cadences)
    WriteCadences(f,g,args.cadences)
    moduleFooters(f,g)

  # transposition
  if args.transposition:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Transposition }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Transposition }} \\noPageBreak\n')
    if args.transposition == 1:
      WrittenTransposition(f,g,random.choice(range(1, len(TranspositionExamplesList))))
    else:
      WrittenTransposition(f,g,args.transposition - 1)
    moduleFooters(f,g)

  # time sigs
  if args.time_sigs:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Time Signatures }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Time Signatures }} \\noPageBreak\n')
    if args.time_sigs == 1:
      TimeSignatures(f,g,random.choice(range(1, len(TimeSigList))))
    else:
      TimeSignatures(f,g,args.time_sigs - 1)
    moduleFooters(f,g)

  # detect errors
  if args.detect_errors:
    f.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Detect Errors }} \\noPageBreak\n')
    g.write('\markup { \override #\'(font-name . "Linux Libertine Capitals Bold") { Detect Errors }} \\noPageBreak\n')
    if args.detect_errors == 1:
      DetectErrors(f,g,random.choice(range(1, len(DetectErrorsList))))
    else:
      DetectErrors(f,g,args.detect_errors - 1)
    moduleFooters(f,g)

  # write footer
  lilypondFooters(f,g)

  f.close()
  g.close()

  # run lilypond
  call(["lilypond", fillInSheet ])
  call(["lilypond", keySheet ])

# call main function
main()
